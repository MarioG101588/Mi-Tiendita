- Archivo 1: HTML principal 

<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>POS Sistema</title>
    <link rel="stylesheet" href="Css/estilo.css">
    <!-- CORREGIDO: Comentar o remover favicon faltante -->
    <!-- <link rel="icon" href="imagenes/logo.png" type="image/png"> -->
</head>
<body>
    <!-- Vista de Login -->
    <div class="container visible" id="container" role="main" aria-label="Vista de login">
        <br><br><br><br><br><br>
        
        <form id="loginForm" class="hidden">
            <label for="emailinicio">Correo:</label>
            <input type="email" id="emailinicio" name="email" required>
            
            <label for="passwordinicio">Contrase√±a:</label>
            <input type="password" id="passwordinicio" name="password" required>
            
            <label>
                <input type="checkbox" id="recordarCheckbox"> Recordar credenciales
            </label>
            
            <button type="button" id="btnIniciarSesion">Iniciar Sesi√≥n</button>
            <button type="button" id="btnCancelar">Cancelar</button>
        </form>
        
        <div id="botonesLogin">
            <button id="loginButton" class="btn">Iniciar Sesi√≥n</button>
            <button id="logoutButton" class="btn hidden">Cerrar Sesi√≥n</button>
        </div>
    </div>

    <!-- Vista de Ventas/POS -->
    <div class="container1 hidden" id="container1" role="main" aria-label="Vista de ventas" data-view="ventas">
        <div class="buscador-container">
            <input type="text" id="campoBusqueda1" class="form-control" placeholder="Buscar productos...">
            <button id="btnVozBuscar" class="btn-voz-buscar" aria-label="B√∫squeda por voz">üé§</button>
        </div>
        
        <div class="pantalla-horizontal">
            <div class="tabla-inventario">
                <div id="inventarioContainer">Cargando inventario...</div>
            </div>
            
            <div class="tabla-carrito">
                <div id="carritoContainer">El carrito est√° vac√≠o</div>
                <div id="totalContainer">Total: $0</div>
                <button id="btnFinalizarVenta" class="btn btn-success">Finalizar Venta</button>
            </div>
        </div>
        
        <div class="navigation-buttons">
            <button class="nav-button btn" data-action="show-view" data-target="container2">Cuentas</button>
            <button class="nav-button btn" data-action="show-view" data-target="container4">Resumen Turno</button>
            <button class="nav-button btn" data-action="show-view" data-target="container5">Historial</button>
            <button class="nav-button btn" data-action="show-view" data-target="container6">Cuentas Pendientes</button>
        </div>
    </div>

    <!-- Vista de Cuentas -->
    <div class="container2 hidden" id="container2" role="main" aria-label="Vista de cuentas" data-view="cuentas">
        <h1>Gesti√≥n de Cuentas</h1>
        <div id="cuentasActivasTurno">Cargando cuentas activas...</div>
        
        <div class="navigation-buttons">
            <button class="nav-button btn" data-action="show-view" data-target="container1">Ventas</button>
            <button class="nav-button btn" data-action="show-view" data-target="container3">Detalle Cuenta</button>
        </div>
    </div>

    <!-- Vista de Detalle de Cuenta -->
    <div class="container3 hidden" id="container3" role="main" aria-label="Vista detalle de cuenta" data-view="detalle-cuenta">
        <h1>Detalle de Cuenta</h1>
        <div id="detalleCuentaContainer">Seleccione una cuenta</div>
        
        <div class="navigation-buttons">
            <button class="nav-button btn" data-action="show-view" data-target="container2">Volver a Cuentas</button>
            <button id="btnPagarCuenta" class="btn btn-success">Pagar Cuenta</button>
        </div>
    </div>

    <!-- Vista de Resumen de Turno -->
    <div class="container4 hidden" id="container4" role="main" aria-label="Vista resumen de turno" data-view="resumen-turno">
        <h1>Resumen del Turno</h1>
        <div id="resumenTurnoDatos">Cargando resumen del turno...</div>
        
        <div class="navigation-buttons">
            <button class="nav-button btn" data-action="show-view" data-target="container1">Volver a Ventas</button>
        </div>
    </div>

    <!-- Vista de Historial de Turnos -->
    <div class="container5 hidden" id="container5" role="main" aria-label="Vista historial de turnos" data-view="historial-turnos">
        <h1>Historial de Turnos</h1>
        <div id="historialTurnosContainer">Cargando historial...</div>
        
        <div class="navigation-buttons">
            <button class="nav-button btn" data-action="show-view" data-target="container1">Volver a Ventas</button>
        </div>
    </div>

    <!-- Vista de Cuentas Pendientes -->
    <div class="container6 hidden" id="container6" role="main" aria-label="Vista cuentas pendientes" data-view="cuentas-pendientes">
        <h1>Cuentas Pendientes</h1>
        <div id="cuentasPendientesContainer">Cargando cuentas pendientes...</div>
        
        <div class="navigation-buttons">
            <button class="nav-button btn" data-action="show-view" data-target="container1">Volver a Ventas</button>
            <button class="nav-button btn" data-action="show-view" data-target="container2">Gesti√≥n de Cuentas</button>
        </div>
    </div>

    <!-- Punto √∫nico de entrada JavaScript -->
    <script type="module" src="JavaScript/Engranaje.js"></script>
</body>
</html>













- Archivo 2: CSS base

/* Estados de visibilidad CORREGIDOS */
.hidden {
    display: none !important;
}

.visible {
    display: block !important;
}

/* Estilos base */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: Arial, sans-serif;
    background-color: #f5f5f5;
    color: #333;
}

/* Contenedores principales */
.container, .container1, .container2, .container3, .container4, .container5, .container6 {
    min-height: 100vh;
    padding: 20px;
    background: white;
    margin: 0;
}

/* Formulario de login */
#loginForm {
    max-width: 400px;
    margin: 0 auto;
    padding: 2rem;
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    border: 1px solid #ddd;
}

#loginForm label {
    display: block;
    margin-bottom: 0.5rem;
    font-weight: bold;
}

#loginForm input {
    width: 100%;
    padding: 0.75rem;
    margin-bottom: 1rem;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 1rem;
}

#loginForm input[type="checkbox"] {
    width: auto;
    margin-right: 0.5rem;
}

/* Botones */
.btn {
    padding: 0.75rem 1.5rem;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 1rem;
    margin: 0.25rem;
    transition: background-color 0.2s;
}

.btn:hover {
    background-color: #0056b3;
}

.btn-success {
    background-color: #28a745;
}

.btn-success:hover {
    background-color: #218838;
}

/* Botones de navegaci√≥n */
#botonesLogin {
    text-align: center;
    margin-top: 2rem;
}

.navigation-buttons {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(255,255,255,0.95);
    padding: 1rem;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.15);
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
    justify-content: center;
}

/* Buscador */
.buscador-container {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1rem;
    max-width: 600px;
}

.form-control {
    flex: 1;
    padding: 0.75rem;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 1rem;
}

.btn-voz-buscar {
    padding: 0.75rem 1rem;
    background-color: #dc3545;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 1.2rem;
}

.btn-voz-buscar:hover {
    background-color: #c82333;
}

/* Layout horizontal para ventas */
.pantalla-horizontal {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 2rem;
    margin-bottom: 80px; /* Espacio para navegaci√≥n fija */
}

.tabla-inventario, .tabla-carrito {
    background: white;
    padding: 1rem;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    border: 1px solid #eee;
}

/* Productos Grid */
.productos-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    gap: 1rem;
    padding: 1rem 0;
    max-height: 600px;
    overflow-y: auto;
}

.producto-card {
    background: white;
    border: 1px solid #ddd;
    border-radius: 8px;
    padding: 1rem;
    text-align: center;
    transition: transform 0.2s, box-shadow 0.2s;
}

.producto-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

.producto-card h4 {
    margin: 0 0 0.5rem 0;
    color: #333;
    font-size: 1rem;
}

.producto-card .precio {
    font-size: 1.2rem;
    font-weight: bold;
    color: #28a745;
    margin: 0.5rem 0;
}

.producto-card .stock {
    color: #6c757d;
    font-size: 0.9rem;
    margin: 0.25rem 0;
}

.producto-card .categoria {
    color: #007bff;
    font-size: 0.8rem;
    margin: 0.25rem 0;
    font-style: italic;
}

/* Carrito Items */
.carrito-items {
    max-height: 400px;
    overflow-y: auto;
    border: 1px solid #eee;
    border-radius: 4px;
    padding: 0.5rem;
    margin: 1rem 0;
}

.carrito-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.75rem;
    border-bottom: 1px solid #eee;
    margin-bottom: 0.5rem;
}

.carrito-item:last-child {
    border-bottom: none;
    margin-bottom: 0;
}

.item-info h5 {
    margin: 0 0 0.25rem 0;
    color: #333;
    font-size: 1rem;
}

.item-info p {
    margin: 0;
    color: #666;
    font-size: 0.9rem;
}

.item-controls {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.item-controls .cantidad {
    min-width: 30px;
    text-align: center;
    font-weight: bold;
}

.item-total {
    font-weight: bold;
    color: #28a745;
    min-width: 80px;
    text-align: right;
}

/* Resumen Total */
.resumen-total {
    background: #f8f9fa;
    padding: 1rem;
    border-radius: 4px;
    border: 2px solid #28a745;
    margin: 1rem 0;
}

.resumen-total div {
    margin: 0.25rem 0;
}

.total-final {
    font-size: 1.2rem;
    border-top: 1px solid #28a745;
    padding-top: 0.5rem;
    margin-top: 0.5rem;
}

/* Botones peque√±os */
.btn-sm {
    padding: 0.25rem 0.5rem;
    font-size: 0.875rem;
}

.btn-danger {
    background-color: #dc3545;
    color: white;
}

.btn-danger:hover {
    background-color: #c82333;
}

/* Estados de error */
.error {
    color: #dc3545;
    background: #f8d7da;
    padding: 0.75rem;
    border: 1px solid #f5c6cb;
    border-radius: 4px;
    margin: 1rem 0;
}

/* Responsivo */
@media (max-width: 768px) {
    .pantalla-horizontal {
        grid-template-columns: 1fr;
        gap: 1rem;
    }
    
    .productos-grid {
        grid-template-columns: 1fr;
    }
    
    .carrito-item {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.5rem;
    }
    
    .item-controls {
        align-self: center;
    }
    
    .item-total {
        align-self: flex-end;
    }
    
    .navigation-buttons {
        position: relative;
        transform: none;
        left: auto;
        bottom: auto;
        margin-top: 2rem;
    }
}

/* Cuentas y tablas */
table {
    width: 100%;
    border-collapse: collapse;
    margin: 1rem 0;
}

table th,
table td {
    padding: 0.75rem;
    text-align: left;
    border-bottom: 1px solid #ddd;
}

table th {
    background-color: #f8f9fa;
    font-weight: bold;
}

/* Estad√≠sticas */
.resumen-turno {
    background: white;
    padding: 1.5rem;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    margin-bottom: 2rem;
}

.estadisticas {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1rem;
    margin-top: 1rem;
}

.stat-card {
    background: #f8f9fa;
    padding: 1rem;
    border-radius: 4px;
    text-align: center;
    border-left: 4px solid #007bff;
}

.stat-card h5 {
    margin: 0 0 0.5rem 0;
    color: #333;
}

.stat-number {
    font-size: 2rem;
    font-weight: bold;
    color: #28a745;
    margin: 0;
}










- Archivo 3: JavaScript de engranaje

// === IMPORTACIONES REQUERIDAS ===
import { inicializarAuth, iniciarSesion, cerrarSesion, observarSesion, getCurrentUser, getRememberedCredentials } from "./Autenticacion.js";
import { obtenerInventario, filtrarInventario } from "./Inventario.js";
import { inicializarCarrito, agregarAlCarrito, obtenerEstadoCarrito, vaciarCarrito, actualizarCantidad, eliminarDelCarrito } from "./CarritoCompras.js";
import { procesarVenta, TIPOS_PAGO } from "./VentasApp.js";
import { obtenerCuentasPendientes, pagarCuenta } from "./Cuentas.js";
import { inicializarReconocimientoVoz, iniciarBusquedaPorVoz } from "./BuscadorVoz.js";

// === ESTADO GLOBAL ===
let inventarioActual = [];
let vistaActual = 'container';
let appReady = false;

// === FUNCIONES DE UTILIDAD ===
function mostrarError(mensaje, elemento = null) {
    console.error('‚ùå', mensaje);
    
    if (elemento) {
        elemento.innerHTML = `<div class="error">${mensaje}</div>`;
    } else {
        // Mostrar en consola o alert como fallback
        if (typeof alert !== 'undefined') {
            alert(`Error: ${mensaje}`);
        }
    }
}

function mostrarCargando(elemento, mensaje = 'Cargando...') {
    if (elemento) {
        elemento.innerHTML = `<div style="text-align: center; padding: 2rem; color: #666;">${mensaje}</div>`;
    }
}

// === FUNCIONES DE NAVEGACI√ìN ===
function mostrarContainer(idMostrar) {
    try {
        console.log(`üì± Navegando a: ${idMostrar}`);
        
        // Ocultar todos los contenedores
        const contenedores = ['container', 'container1', 'container2', 'container3', 'container4', 'container5', 'container6'];
        
        contenedores.forEach(id => {
            const elemento = document.getElementById(id);
            if (elemento) {
                elemento.classList.remove('visible');
                elemento.classList.add('hidden');
            }
        });
        
        // Mostrar el contenedor solicitado
        const contenedorDestino = document.getElementById(idMostrar);
        if (contenedorDestino) {
            contenedorDestino.classList.remove('hidden');
            contenedorDestino.classList.add('visible');
            vistaActual = idMostrar;
            
            // Cargar datos espec√≠ficos seg√∫n la vista
            setTimeout(() => cargarDatosVista(idMostrar), 100);
        } else {
            console.error(`Contenedor no encontrado: ${idMostrar}`);
        }
        
    } catch (error) {
        console.error('Error en navegaci√≥n:', error);
    }
}

async function cargarDatosVista(vista) {
    try {
        switch(vista) {
            case 'container1':
                await cargarInventarioVista();
                await renderCarritoVista();
                break;
            case 'container2':
                await cargarCuentasActivasVista();
                break;
            case 'container4':
                await cargarResumenTurnoVista();
                break;
            case 'container6':
                await cargarCuentasPendientesVista();
                break;
        }
    } catch (error) {
        console.error(`Error cargando vista ${vista}:`, error);
    }
}

// === FUNCIONES DE VISTA DE INVENTARIO ===
async function cargarInventarioVista(filtro = '') {
    const container = document.getElementById('inventarioContainer');
    if (!container) return;
    
    try {
        mostrarCargando(container, 'Cargando inventario...');
        
        if (inventarioActual.length === 0) {
            inventarioActual = await obtenerInventario();
        }
        
        const productosFiltrados = filtro ? 
            await filtrarInventario(filtro, inventarioActual) : 
            inventarioActual;
        
        if (productosFiltrados.length === 0) {
            container.innerHTML = '<div style="text-align: center; padding: 2rem; color: #666;">No se encontraron productos.</div>';
            return;
        }
        
        let html = '<div class="productos-grid">';
        
        productosFiltrados.forEach(producto => {
            html += `
                <div class="producto-card" data-id="${producto.id}">
                    <h4>${producto.nombre}</h4>
                    <p class="precio">$${producto.precio.toLocaleString()}</p>
                    <p class="stock">Stock: ${producto.cantidad}</p>
                    <p class="categoria">${producto.categoria || 'Sin categor√≠a'}</p>
                    <button class="btn btn-success" onclick="agregarProductoAlCarrito('${producto.id}')">
                        Agregar al Carrito
                    </button>
                </div>
            `;
        });
        
        html += '</div>';
        container.innerHTML = html;
        
    } catch (error) {
        mostrarError('Error al cargar el inventario: ' + error.message, container);
    }
}

// === FUNCIONES DE CARRITO ===
async function renderCarritoVista() {
    const container = document.getElementById('carritoContainer');
    const totalContainer = document.getElementById('totalContainer');
    
    if (!container) return;
    
    try {
        const estadoCarrito = obtenerEstadoCarrito();
        
        if (estadoCarrito.estaVacio) {
            container.innerHTML = '<div style="text-align: center; padding: 2rem; color: #666;">No hay productos en el carrito.</div>';
            if (totalContainer) {
                totalContainer.innerHTML = '<div class="resumen-total"><div><strong>Total: $0</strong></div></div>';
            }
            return;
        }
        
        let html = '<div class="carrito-items">';
        
        estadoCarrito.items.forEach(item => {
            html += `
                <div class="carrito-item" data-id="${item.id}">
                    <div class="item-info">
                        <h5>${item.nombre}</h5>
                        <p>$${item.precio.toLocaleString()} x ${item.cantidad}</p>
                    </div>
                    <div class="item-controls">
                        <button class="btn btn-sm" onclick="cambiarCantidadCarrito('${item.id}', -1)">-</button>
                        <span class="cantidad">${item.cantidad}</span>
                        <button class="btn btn-sm" onclick="cambiarCantidadCarrito('${item.id}', 1)">+</button>
                        <button class="btn btn-danger btn-sm" onclick="eliminarDelCarritoVista('${item.id}')">üóëÔ∏è</button>
                    </div>
                    <div class="item-total">
                        $${item.subtotal.toLocaleString()}
                    </div>
                </div>
            `;
        });
        
        html += '</div>';
        container.innerHTML = html;
        
        // Actualizar total
        if (totalContainer) {
            totalContainer.innerHTML = `
                <div class="resumen-total">
                    <div>Subtotal: $${estadoCarrito.totales.subtotal.toLocaleString()}</div>
                    <div>IVA (19%): $${estadoCarrito.totales.iva.toLocaleString()}</div>
                    <div class="total-final"><strong>Total: $${estadoCarrito.totales.total.toLocaleString()}</strong></div>
                </div>
            `;
        }
        
    } catch (error) {
        mostrarError('Error al mostrar el carrito: ' + error.message, container);
    }
}

// === FUNCIONES DE CUENTAS ===
async function cargarCuentasActivasVista() {
    const container = document.getElementById('cuentasActivasTurno');
    if (!container) return;
    
    try {
        mostrarCargando(container, 'Cargando cuentas activas...');
        
        // Aqu√≠ cargar√≠as las cuentas reales del turno actual
        setTimeout(() => {
            container.innerHTML = `
                <div style="background: #f8f9fa; padding: 1rem; border-radius: 4px; border-left: 4px solid #007bff;">
                    <h4>Cuentas del Turno Actual</h4>
                    <p>No hay cuentas activas en este turno.</p>
                </div>
            `;
        }, 500);
        
    } catch (error) {
        mostrarError('Error al cargar cuentas activas: ' + error.message, container);
    }
}

async function cargarCuentasPendientesVista() {
    const container = document.getElementById('cuentasPendientesContainer');
    if (!container) return;
    
    try {
        mostrarCargando(container, 'Cargando cuentas pendientes...');
        
        const cuentasPendientes = await obtenerCuentasPendientes();
        
        if (cuentasPendientes.length === 0) {
            container.innerHTML = '<div style="text-align: center; padding: 2rem; color: #666;">No hay cuentas pendientes.</div>';
            return;
        }
        
        let html = `
            <table>
                <thead>
                    <tr>
                        <th>Cliente</th>
                        <th>Monto</th>
                        <th>Fecha</th>
                        <th>Estado</th>
                        <th>Acciones</th>
                    </tr>
                </thead>
                <tbody>
        `;
        
        cuentasPendientes.forEach(cuenta => {
            const fecha = cuenta.fechaCreacion ? 
                new Date(cuenta.fechaCreacion.seconds * 1000).toLocaleDateString() : 
                'N/A';
            
            html += `
                <tr>
                    <td>${cuenta.clienteNombre || 'Cliente'}</td>
                    <td>$${cuenta.saldoPendiente.toLocaleString()}</td>
                    <td>${fecha}</td>
                    <td>${cuenta.estado}</td>
                    <td>
                        <button class="btn btn-success btn-sm" onclick="pagarCuentaVista('${cuenta.id}')">
                            Pagar
                        </button>
                    </td>
                </tr>
            `;
        });
        
        html += '</tbody></table>';
        container.innerHTML = html;
        
    } catch (error) {
        mostrarError('Error al cargar cuentas pendientes: ' + error.message, container);
    }
}

async function cargarResumenTurnoVista() {
    const container = document.getElementById('resumenTurnoDatos');
    if (!container) return;
    
    try {
        const usuario = getCurrentUser();
        const turnoId = localStorage.getItem('pos_current_turno_id');
        
        container.innerHTML = `
            <div class="resumen-turno">
                <h4>Resumen del Turno</h4>
                <p><strong>Usuario:</strong> ${usuario?.email || 'No definido'}</p>
                <p><strong>Turno ID:</strong> ${turnoId || 'No definido'}</p>
                <p><strong>Inicio:</strong> ${new Date().toLocaleString()}</p>
                <div class="estadisticas">
                    <div class="stat-card">
                        <h5>Ventas Realizadas</h5>
                        <p class="stat-number">0</p>
                    </div>
                    <div class="stat-card">
                        <h5>Total Vendido</h5>
                        <p class="stat-number">$0</p>
                    </div>
                </div>
            </div>
        `;
        
    } catch (error) {
        mostrarError('Error al cargar resumen del turno: ' + error.message, container);
    }
}

// === FUNCIONES DE INTERACCI√ìN (GLOBALES) ===
window.mostrarContainer = mostrarContainer;

window.agregarProductoAlCarrito = async function(productId) {
    try {
        const resultado = await agregarAlCarrito(productId, 1);
        if (resultado.success) {
            await renderCarritoVista();
            console.log('‚úÖ Producto agregado al carrito');
        }
    } catch (error) {
        console.error('Error agregando al carrito:', error);
        mostrarError('Error al agregar producto al carrito: ' + error.message);
    }
};

window.cambiarCantidadCarrito = async function(productId, cambio) {
    try {
        const estadoActual = obtenerEstadoCarrito();
        const itemActual = estadoActual.items.find(i => i.id === productId);
        
        if (!itemActual) return;
        
        const nuevaCantidad = itemActual.cantidad + cambio;
        
        if (nuevaCantidad <= 0) {
            window.eliminarDelCarritoVista(productId);
            return;
        }
        
        const resultado = await actualizarCantidad(productId, nuevaCantidad);
        
        if (resultado.success) {
            await renderCarritoVista();
        }
        
    } catch (error) {
        console.error('Error cambiando cantidad:', error);
        mostrarError('Error al cambiar cantidad: ' + error.message);
    }
};

window.eliminarDelCarritoVista = async function(productId) {
    try {
        const resultado = eliminarDelCarrito(productId);
        
        if (resultado.success) {
            await renderCarritoVista();
        }
        
    } catch (error) {
        console.error('Error eliminando del carrito:', error);
        mostrarError('Error al eliminar del carrito: ' + error.message);
    }
};

window.finalizarVentaVista = async function() {
    try {
        const estadoCarrito = obtenerEstadoCarrito();
        
        if (estadoCarrito.estaVacio) {
            mostrarError('El carrito est√° vac√≠o');
            return;
        }
        
        // Seleccionar tipo de pago
        const tipoPago = prompt('Seleccione m√©todo de pago:\n1. Efectivo\n2. Tarjeta\n3. Transferencia', '1');
        
        let tipoSeleccionado;
        switch(tipoPago) {
            case '1': tipoSeleccionado = TIPOS_PAGO.EFECTIVO; break;
            case '2': tipoSeleccionado = TIPOS_PAGO.TARJETA; break;
            case '3': tipoSeleccionado = TIPOS_PAGO.TRANSFERENCIA; break;
            default: tipoSeleccionado = TIPOS_PAGO.EFECTIVO;
        }
        
        const resultado = await procesarVenta(estadoCarrito.items, tipoSeleccionado, {
            total: estadoCarrito.totales.total
        });
        
        if (resultado.success) {
            alert('‚úÖ Venta procesada correctamente');
            vaciarCarrito();
            await renderCarritoVista();
        }
        
    } catch (error) {
        console.error('Error procesando venta:', error);
        mostrarError('Error al procesar la venta: ' + error.message);
    }
};

window.pagarCuentaVista = async function(cuentaId) {
    try {
        const monto = prompt('Ingrese el monto del pago:');
        if (!monto || isNaN(monto)) return;
        
        const resultado = await pagarCuenta(cuentaId, {
            monto: parseFloat(monto),
            metodoPago: 'efectivo'
        });
        
        if (resultado.success) {
            alert('‚úÖ Pago procesado correctamente');
            await cargarCuentasPendientesVista();
        }
        
    } catch (error) {
        console.error('Error procesando pago:', error);
        mostrarError('Error al procesar el pago: ' + error.message);
    }
};

// === INICIALIZACI√ìN DE LA APLICACI√ìN ===
async function inicializarApp() {
    try {
        console.log('üöÄ Iniciando aplicaci√≥n POS...');
        
        // 1. Inicializar autenticaci√≥n
        await inicializarAuth();
        
        // 2. Inicializar carrito
        inicializarCarrito();
        
        // 3. Inicializar reconocimiento de voz
        try {
            await inicializarReconocimientoVoz();
            console.log('üé§ Reconocimiento de voz inicializado');
        } catch (error) {
            console.warn('‚ö†Ô∏è Reconocimiento de voz no disponible:', error.message);
        }
        
        appReady = true;
        console.log('‚úÖ Aplicaci√≥n inicializada correctamente');
        
    } catch (error) {
        console.error('‚ùå Error inicializando aplicaci√≥n:', error);
        mostrarError('Error al inicializar la aplicaci√≥n: ' + error.message);
    }
}

// === CONFIGURACI√ìN DE EVENTOS DOM ===
document.addEventListener('DOMContentLoaded', async function() {
    try {
        console.log('üîß Configurando eventos DOM...');
        
        // Inicializar aplicaci√≥n
        await inicializarApp();
        
        // Configurar b√∫squeda
        const campoBusqueda = document.getElementById('campoBusqueda1');
        if (campoBusqueda) {
            campoBusqueda.addEventListener('input', function() {
                const filtro = this.value;
                if (vistaActual === 'container1') {
                    cargarInventarioVista(filtro);
                }
            });
        }
        
        // Configurar b√∫squeda por voz
        const btnVoz = document.getElementById('btnVozBuscar');
        if (btnVoz) {
            btnVoz.addEventListener('click', async function() {
                try {
                    btnVoz.textContent = 'üî¥';
                    btnVoz.disabled = true;
                    
                    await iniciarBusquedaPorVoz((resultado) => {
                        if (resultado.isFinal && campoBusqueda) {
                            campoBusqueda.value = resultado.textoBusqueda || resultado.transcript;
                            cargarInventarioVista(campoBusqueda.value);
                        }
                    });
                    
                } catch (error) {
                    console.error('Error con b√∫squeda por voz:', error);
                    mostrarError('Error en b√∫squeda por voz: ' + error.message);
                } finally {
                    btnVoz.textContent = 'üé§';
                    btnVoz.disabled = false;
                }
            });
        }
        
        // Configurar botones de navegaci√≥n
        const navButtons = document.querySelectorAll('.nav-button[data-action="show-view"]');
        navButtons.forEach(button => {
            button.addEventListener('click', function() {
                const target = this.getAttribute('data-target');
                if (target) {
                    mostrarContainer(target);
                }
            });
        });
        
        // Configurar bot√≥n finalizar venta
        const btnFinalizar = document.getElementById('btnFinalizarVenta');
        if (btnFinalizar) {
            btnFinalizar.addEventListener('click', window.finalizarVentaVista);
        }
        
        // Configurar formulario de login
        const loginButton = document.getElementById('loginButton');
        const loginForm = document.getElementById('loginForm');
        const btnIniciarSesion = document.getElementById('btnIniciarSesion');
        const btnCancelar = document.getElementById('btnCancelar');
        const logoutButton = document.getElementById('logoutButton');
        
        if (loginButton) {
            loginButton.addEventListener('click', function() {
                if (loginForm) {
                    const isHidden = loginForm.classList.contains('hidden');
                    if (isHidden) {
                        loginForm.classList.remove('hidden');
                        this.textContent = 'Cancelar';
                    } else {
                        loginForm.classList.add('hidden');
                        this.textContent = 'Iniciar Sesi√≥n';
                    }
                }
            });
        }
        
        if (btnCancelar) {
            btnCancelar.addEventListener('click', function() {
                if (loginForm) {
                    loginForm.classList.add('hidden');
                }
                if (loginButton) {
                    loginButton.textContent = 'Iniciar Sesi√≥n';
                }
            });
        }
        
        if (btnIniciarSesion) {
            btnIniciarSesion.addEventListener('click', async function() {
                const email = document.getElementById('emailinicio')?.value;
                const password = document.getElementById('passwordinicio')?.value;
                const recordar = document.getElementById('recordarCheckbox')?.checked;
                
                if (!email || !password) {
                    mostrarError('Por favor complete todos los campos');
                    return;
                }
                
                try {
                    btnIniciarSesion.disabled = true;
                    btnIniciarSesion.textContent = 'Iniciando...';
                    
                    const resultado = await iniciarSesion(email, password, recordar);
                    
                    if (resultado.success) {
                        mostrarContainer('container1');
                        if (loginForm) loginForm.classList.add('hidden');
                        if (loginButton) loginButton.textContent = 'Iniciar Sesi√≥n';
                    }
                    
                } catch (error) {
                    console.error('Error en login:', error);
                    mostrarError('Error al iniciar sesi√≥n: ' + error.message);
                } finally {
                    btnIniciarSesion.disabled = false;
                    btnIniciarSesion.textContent = 'Iniciar Sesi√≥n';
                }
            });
        }
        
        if (logoutButton) {
            logoutButton.addEventListener('click', async function() {
                try {
                    if (confirm('¬øEst√° seguro que desea cerrar sesi√≥n?')) {
                        const resultado = await cerrarSesion();
                        if (resultado.success) {
                            mostrarContainer('container');
                        }
                    }
                } catch (error) {
                    console.error('Error cerrando sesi√≥n:', error);
                    mostrarError('Error al cerrar sesi√≥n: ' + error.message);
                }
            });
        }
        
        // Restaurar credenciales si est√°n guardadas
        try {
            const credenciales = getRememberedCredentials();
            if (credenciales.recordar) {
                const emailInput = document.getElementById('emailinicio');
                const recordarCheckbox = document.getElementById('recordarCheckbox');
                
                if (emailInput) emailInput.value = credenciales.email;
                if (recordarCheckbox) recordarCheckbox.checked = true;
            }
        } catch (error) {
            console.warn('Error cargando credenciales guardadas:', error);
        }
        
        // Observar cambios de sesi√≥n
        observarSesion((user) => {
            const loginButton = document.getElementById('loginButton');
            const logoutButton = document.getElementById('logoutButton');
            
            if (user) {
                // Usuario logueado
                if (loginButton) loginButton.classList.add('hidden');
                if (logoutButton) logoutButton.classList.remove('hidden');
                
                if (vistaActual === 'container') {
                    mostrarContainer('container1');
                }
            } else {
                // Usuario deslogueado
                if (loginButton) loginButton.classList.remove('hidden');
                if (logoutButton) logoutButton.classList.add('hidden');
                
                mostrarContainer('container');
            }
        });
        
        // Mostrar vista inicial
        mostrarContainer('container');
        
        console.log('‚úÖ Eventos DOM configurados correctamente');
        
    } catch (error) {
        console.error('‚ùå Error configurando eventos DOM:', error);
        mostrarError('Error al configurar la aplicaci√≥n: ' + error.message);
    }
});














- Archivo 4: JavaScript conexion

// === CONFIGURACI√ìN Y CONEXI√ìN A FIREBASE ===
// Este m√≥dulo centraliza toda la l√≥gica de conexi√≥n con Firebase
// y proporciona una instancia configurada y validada para el resto de la aplicaci√≥n

// Importaciones de Firebase v11
import { initializeApp, getApps } from "https://www.gstatic.com/firebasejs/11.6.0/firebase-app.js";
import { getAuth } from "https://www.gstatic.com/firebasejs/11.6.0/firebase-auth.js";
import { getFirestore } from "https://www.gstatic.com/firebasejs/11.6.0/firebase-firestore.js";

// === CONFIGURACI√ìN REAL DESDE EL ARCHIVO TXT ===
const firebaseConfig = {
    apiKey: "AIzaSyCygT0WyAVlV_AvlOXSPyQht6KlpALPZ10",
    authDomain: "poss25.firebaseapp.com", 
    projectId: "poss25",
    storageBucket: "poss25.appspot.com",
    messagingSenderId: "797163205747",
    appId: "1:797163205747:web:7455fe43c4683c59aee606"
};

// Inicializar Firebase
let app = null;
let auth = null;
let db = null;

try {
    const existingApps = getApps();
    if (existingApps.length > 0) {
        app = existingApps[0];
    } else {
        app = initializeApp(firebaseConfig);
    }
    
    auth = getAuth(app);
    db = getFirestore(app);
    
    console.log('‚úÖ Firebase inicializado correctamente');
} catch (error) {
    console.error('‚ùå Error inicializando Firebase:', error);
}

export { app, auth, db };













- Archivo 5: JavaScript autenticaci√≥n

// === AUTENTICACION.JS - M√ìDULO BLINDADO DE GESTI√ìN DE USUARIOS Y TURNOS ===

// === IMPORTACIONES REQUERIDAS ===
import { 
    getAuth, 
    signInWithEmailAndPassword, 
    signOut, 
    onAuthStateChanged 
} from "https://www.gstatic.com/firebasejs/11.6.0/firebase-auth.js";

import { 
    getFirestore, 
    collection, 
    doc, 
    getDoc, 
    setDoc, 
    updateDoc, 
    serverTimestamp,
    query,
    where,
    getDocs,
    orderBy,
    limit,
    writeBatch
} from "https://www.gstatic.com/firebasejs/11.6.0/firebase-firestore.js";

import { app } from "./Conexion.js";

// === INICIALIZACI√ìN DE SERVICIOS ===
const auth = getAuth(app);
const db = getFirestore(app);

// === ESTADO INTERNO DEL M√ìDULO ===
let currentUser = null;
let currentTurno = null;
let authStateListeners = [];
let isInitialized = false;
let sessionCheckInterval = null;

// === CONSTANTES DE CONFIGURACI√ìN ===
const ROLES_USUARIO = {
    ADMIN: 'admin',
    TENDERO: 'tendero'
};

const ESTADOS_TURNO = {
    ABIERTO: 'abierto',
    CERRADO: 'cerrado'
};

const SESSION_CHECK_INTERVAL = 30000; // 30 segundos
const SESSION_TIMEOUT = 8 * 60 * 60 * 1000; // 8 horas en millisegundos

// === FUNCIONES DE UTILIDAD ===

/**
 * Genera un ID √∫nico para turnos con m√°xima unicidad
 * @returns {string} ID √∫nico basado en timestamp + usuario + random
 */
function generarIdTurno() {
    const now = new Date();
    const timestamp = now.getTime();
    const dateStr = `${now.getFullYear()}${(now.getMonth() + 1).toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}`;
    const timeStr = `${now.getHours().toString().padStart(2, '0')}${now.getMinutes().toString().padStart(2, '0')}${now.getSeconds().toString().padStart(2, '0')}`;
    const randomStr = Math.random().toString(36).substr(2, 8);
    
    return `turno_${dateStr}_${timeStr}_${timestamp}_${randomStr}`;
}

/**
 * Genera un token √∫nico de sesi√≥n con m√°xima seguridad
 * @returns {string} Token √∫nico
 */
function generarSesionToken() {
    const timestamp = Date.now();
    const random1 = Math.random().toString(36).substr(2, 16);
    const random2 = Math.random().toString(36).substr(2, 16);
    return `session_${timestamp}_${random1}_${random2}`;
}

/**
 * Valida la estructura de un usuario
 * @param {Object} userData - Datos del usuario
 * @returns {boolean} True si la estructura es v√°lida
 */
function validarEstructuraUsuario(userData) {
    return userData && 
           typeof userData.email === 'string' &&
           typeof userData.role === 'string' &&
           typeof userData.sesionActiva === 'boolean';
}

/**
 * Valida la estructura de un turno
 * @param {Object} turnoData - Datos del turno
 * @returns {boolean} True si la estructura es v√°lida
 */
function validarEstructuraTurno(turnoData) {
    return turnoData &&
           typeof turnoData.idTurno === 'string' &&
           typeof turnoData.usuario === 'string' &&
           typeof turnoData.estado === 'string' &&
           Object.values(ESTADOS_TURNO).includes(turnoData.estado);
}

// === FUNCIONES DE GESTI√ìN DE USUARIOS ===

/**
 * Obtiene los datos del usuario desde Firestore con validaciones
 * @param {string} email - Email del usuario
 * @returns {Promise<Object|null>} Datos del usuario o null
 */
async function obtenerDatosUsuario(email) {
    try {
        if (!email?.trim()) {
            throw new Error('Email requerido para obtener datos del usuario');
        }

        // üîß CORRECCI√ìN: Usar colecci√≥n 'usuarion' y email como ID
        const userRef = doc(db, "usuarion", email);
        const userSnap = await getDoc(userRef);
        
        if (!userSnap.exists()) {
            console.warn(`‚ö†Ô∏è Usuario no encontrado en Firestore: ${email}`);
            return null;
        }

        const userData = userSnap.data();
        
        // Validar estructura de datos
        if (!validarEstructuraUsuario(userData)) {
            console.error('‚ùå Estructura de usuario inv√°lida:', userData);
            throw new Error('Estructura de datos de usuario inv√°lida');
        }

        const usuarioCompleto = {
            email: userSnap.id,
            apellido: userData.apellido || '',
            nombre: userData.nombre || '',
            documento: userData.documento || '',
            role: userData.role || ROLES_USUARIO.TENDERO,
            sesionActiva: Boolean(userData.sesionActiva),
            sesionToken: userData.sesionToken || '',
            telefono: userData.telefono || '',
            tipoDocumento: userData.tipoDocumento || '',
            uid: userData.uid || '',
            fechaRegistro: userData.fechaRegistro || null,
            fechaUltimaActividad: userData.fechaUltimaActividad || null
        };
        
        return usuarioCompleto;
        
    } catch (error) {
        console.error('‚ùå Error obteniendo datos del usuario:', error);
        throw {
            code: 'auth/user-data-error',
            message: 'Error al obtener los datos del usuario',
            originalError: error
        };
    }
}

/**
 * Actualiza el estado de sesi√≥n del usuario en Firestore con transacci√≥n
 * @param {string} email - Email del usuario
 * @param {boolean} activa - Estado de la sesi√≥n
 * @param {string} token - Token de sesi√≥n
 * @returns {Promise<void>}
 */
async function actualizarEstadoSesionUsuario(email, activa, token = '') {
    try {
        if (!email?.trim()) {
            throw new Error('Email requerido para actualizar estado de sesi√≥n');
        }

        // üîß CORRECCI√ìN: Usar colecci√≥n 'usuarion'
        const userRef = doc(db, "usuarion", email);
        
        const datosActualizacion = {
            sesionActiva: Boolean(activa),
            sesionToken: activa ? token : '',
            fechaUltimaActividad: serverTimestamp()
        };

        await updateDoc(userRef, datosActualizacion);
        
        console.log(`‚úÖ Estado de sesi√≥n actualizado para ${email}: ${activa ? 'ACTIVA' : 'INACTIVA'}`);
        
    } catch (error) {
        console.error('‚ùå Error actualizando estado de sesi√≥n:', error);
        throw {
            code: 'auth/session-update-error',
            message: 'Error al actualizar el estado de sesi√≥n',
            originalError: error
        };
    }
}

// === FUNCIONES DE GESTI√ìN DE TURNOS ===

/**
 * Crea un nuevo turno en Firestore con validaciones completas
 * @param {string} email - Email del usuario
 * @returns {Promise<string>} ID del turno creado
 */
async function crearTurno(email) {
    try {
        if (!email?.trim()) {
            throw new Error('Email requerido para crear turno');
        }

        const idTurno = generarIdTurno();
        
        // üîß CORRECCI√ìN: Usar colecci√≥n 'turnos' con idTurno como ID
        const turnoRef = doc(db, "turnos", idTurno);
        
        const datosTurno = {
            idTurno: idTurno,                    // ‚úÖ Campo requerido seg√∫n estructura
            usuario: email,                      // ‚úÖ Email del usuario  
            estado: ESTADOS_TURNO.ABIERTO,       // ‚úÖ Estado: "abierto"
            fechaInicio: serverTimestamp(),      // ‚úÖ Fecha de inicio
            fechaFin: null                       // ‚úÖ Null hasta que se cierre
        };
        
        // Validar estructura antes de guardar
        if (!validarEstructuraTurno({ ...datosTurno, fechaInicio: new Date() })) {
            throw new Error('Estructura de turno inv√°lida');
        }

        await setDoc(turnoRef, datosTurno);
        
        console.log(`‚úÖ Turno creado exitosamente: ${idTurno} para usuario: ${email}`);
        return idTurno;
        
    } catch (error) {
        console.error('‚ùå Error creando turno:', error);
        throw {
            code: 'auth/turno-creation-error',
            message: 'Error al crear el turno',
            originalError: error
        };
    }
}

/**
 * Cierra un turno activo con validaciones
 * @param {string} idTurno - ID del turno a cerrar
 * @returns {Promise<void>}
 */
async function cerrarTurno(idTurno) {
    try {
        if (!idTurno?.trim()) {
            throw new Error('ID de turno requerido para cerrar');
        }

        // üîß CORRECCI√ìN: Usar colecci√≥n 'turnos'
        const turnoRef = doc(db, "turnos", idTurno);
        
        // Verificar que el turno existe y est√° abierto
        const turnoSnap = await getDoc(turnoRef);
        if (!turnoSnap.exists()) {
            console.warn(`‚ö†Ô∏è Turno no encontrado para cerrar: ${idTurno}`);
            return; // No error, solo advertencia
        }

        const turnoData = turnoSnap.data();
        if (turnoData.estado === ESTADOS_TURNO.CERRADO) {
            console.warn(`‚ö†Ô∏è Turno ya estaba cerrado: ${idTurno}`);
            return; // Ya est√° cerrado, no hacer nada
        }

        const datosActualizacion = {
            estado: ESTADOS_TURNO.CERRADO,       // ‚úÖ Estado: "cerrado"
            fechaFin: serverTimestamp()          // ‚úÖ Fecha de cierre
        };

        await updateDoc(turnoRef, datosActualizacion);
        
        console.log(`‚úÖ Turno cerrado exitosamente: ${idTurno}`);
        
    } catch (error) {
        console.error('‚ùå Error cerrando turno:', error);
        throw {
            code: 'auth/turno-close-error',
            message: 'Error al cerrar el turno',
            originalError: error
        };
    }
}

/**
 * Obtiene el turno activo de un usuario con validaciones
 * @param {string} email - Email del usuario
 * @returns {Promise<Object|null>} Datos del turno activo o null
 */
async function obtenerTurnoActivo(email) {
    try {
        if (!email?.trim()) {
            return null;
        }

        // üîß CORRECCI√ìN: Consultar colecci√≥n 'turnos'
        const turnosRef = collection(db, "turnos");
        const q = query(
            turnosRef,
            where("usuario", "==", email),
            where("estado", "==", ESTADOS_TURNO.ABIERTO),
            orderBy("fechaInicio", "desc"),
            limit(1)
        );
        
        const querySnapshot = await getDocs(q);
        
        if (querySnapshot.empty) {
            return null;
        }

        const turnoDoc = querySnapshot.docs[0];
        const turnoData = turnoDoc.data();
        
        // Validar estructura
        if (!validarEstructuraTurno(turnoData)) {
            console.error('‚ùå Estructura de turno inv√°lida:', turnoData);
            return null;
        }

        return {
            id: turnoDoc.id,
            idTurno: turnoData.idTurno,
            usuario: turnoData.usuario,
            estado: turnoData.estado,
            fechaInicio: turnoData.fechaInicio,
            fechaFin: turnoData.fechaFin
        };
        
    } catch (error) {
        console.error('‚ùå Error obteniendo turno activo:', error);
        throw {
            code: 'auth/turno-fetch-error',
            message: 'Error al obtener el turno activo',
            originalError: error
        };
    }
}

/**
 * üõ°Ô∏è NUEVA FUNCI√ìN: Limpia turnos hu√©rfanos de un usuario
 * @param {string} email - Email del usuario
 * @returns {Promise<number>} N√∫mero de turnos cerrados
 */
async function limpiarTurnosHuerfanos(email) {
    try {
        const turnosRef = collection(db, "turnos");
        const q = query(
            turnosRef,
            where("usuario", "==", email),
            where("estado", "==", ESTADOS_TURNO.ABIERTO)
        );
        
        const querySnapshot = await getDocs(q);
        
        if (querySnapshot.empty) {
            return 0;
        }

        const batch = writeBatch(db);
        let turnosCerrados = 0;

        querySnapshot.forEach(docSnap => {
            batch.update(docSnap.ref, {
                estado: ESTADOS_TURNO.CERRADO,
                fechaFin: serverTimestamp(),
                cerradoPor: 'sistema_limpieza'
            });
            turnosCerrados++;
            console.log(`üßπ Turno hu√©rfano marcado para cierre: ${docSnap.data().idTurno}`);
        });

        await batch.commit();
        
        console.log(`‚úÖ ${turnosCerrados} turnos hu√©rfanos cerrados para usuario: ${email}`);
        return turnosCerrados;
        
    } catch (error) {
        console.error('‚ùå Error limpiando turnos hu√©rfanos:', error);
        return 0; // No fallar por esto
    }
}

// === FUNCIONES PRINCIPALES DE AUTENTICACI√ìN BLINDADAS ===

/**
 * üõ°Ô∏è Inicia sesi√≥n de usuario CON M√ÅXIMA SEGURIDAD
 * @param {string} email - Email del usuario
 * @param {string} password - Contrase√±a
 * @returns {Promise<Object>} Resultado del inicio de sesi√≥n
 */
export async function iniciarSesion(email, password) {
    try {
        // Validar par√°metros
        if (!email?.trim() || !password?.trim()) {
            throw {
                code: 'auth/invalid-credentials',
                message: 'Email y contrase√±a son requeridos'
            };
        }

        console.log(`üîÑ Iniciando sesi√≥n BLINDADA para: ${email}`);
        
        // 1. ‚úÖ AUTENTICACI√ìN FIREBASE AUTH
        const userCredential = await signInWithEmailAndPassword(auth, email, password);
        const firebaseUser = userCredential.user;
        
        // 2. ‚úÖ OBTENER DATOS DEL USUARIO DESDE 'usuarion'
        const userData = await obtenerDatosUsuario(email);
        
        if (!userData) {
            // Cerrar sesi√≥n de Firebase inmediatamente
            await signOut(auth);
            throw {
                code: 'auth/user-not-found-in-firestore',
                message: 'Usuario no encontrado en la base de datos'
            };
        }
        
        // 3. üõ°Ô∏è VERIFICACI√ìN CR√çTICA: PREVENIR SESIONES DUPLICADAS
        if (userData.sesionActiva === true) {
            // Cerrar sesi√≥n de Firebase para este intento
            await signOut(auth);
            
            throw {
                code: 'auth/session-already-active',
                message: 'El usuario ya tiene una sesi√≥n activa en otro dispositivo. Cierre esa sesi√≥n primero.',
                details: {
                    usuarioEmail: email,
                    sesionToken: userData.sesionToken,
                    requiereLogoutForzado: true,
                    fechaUltimaActividad: userData.fechaUltimaActividad
                }
            };
        }
        
        // 4. üõ°Ô∏è LIMPIEZA DE TURNOS HU√âRFANOS (CR√çTICO PARA INTEGRIDAD)
        const turnosHuerfanosCerrados = await limpiarTurnosHuerfanos(email);
        if (turnosHuerfanosCerrados > 0) {
            console.log(`üßπ ${turnosHuerfanosCerrados} turnos hu√©rfanos limpiados`);
        }
        
        // 5. ‚úÖ CREAR NUEVO TURNO (SIEMPRE NUEVO PARA GARANTIZAR INTEGRIDAD)
        const idTurno = await crearTurno(email);
        console.log(`üÜï Nuevo turno creado: ${idTurno}`);
        
        // 6. üõ°Ô∏è ACTUALIZAR ESTADO SESI√ìN EN 'usuarion' (CR√çTICO)
        const sesionToken = generarSesionToken();
        await actualizarEstadoSesionUsuario(email, true, sesionToken);
        
        // 7. ‚úÖ ACTUALIZAR ESTADO INTERNO CON VALIDACIONES
        currentUser = {
            ...userData,
            uid: firebaseUser.uid,
            sesionToken: sesionToken,
            sesionActiva: true,
            fechaInicioSesion: new Date().toISOString()
        };
        
        currentTurno = {
            idTurno: idTurno,
            usuario: email,
            estado: ESTADOS_TURNO.ABIERTO,
            fechaInicio: new Date()
        };

        // 8. ‚úÖ INICIAR MONITOREO DE SESI√ìN
        iniciarMonitoreoSesion();
        
        console.log(`‚úÖ SESI√ìN BLINDADA INICIADA para: ${email}`);
        console.log(`üéØ Turno activo: ${idTurno}`);
        console.log(`üîê Estado de sesi√≥n: ACTIVA`);
        console.log(`üõ°Ô∏è Token generado: ${sesionToken.substring(0, 20)}...`);
        
        // Notificar a los listeners
        notificarCambioAuth(currentUser);
        
        return {
            success: true,
            user: currentUser,
            turno: currentTurno,
            message: 'Sesi√≥n iniciada correctamente',
            esNuevaSesion: true,
            turnosHuerfanosLimpiados: turnosHuerfanosCerrados,
            seguridadAplicada: true
        };
        
    } catch (error) {
        console.error('‚ùå Error en inicio de sesi√≥n BLINDADO:', error);
        
        // Limpiar estado en caso de error
        currentUser = null;
        currentTurno = null;
        detenerMonitoreoSesion();
        
        if (error.code) {
            throw error;
        }
        
        throw {
            code: 'auth/signin-error',
            message: 'Error al iniciar sesi√≥n',
            originalError: error
        };
    }
}

/**
 * üõ°Ô∏è Cierra sesi√≥n del usuario CON VERIFICACIONES COMPLETAS
 * @param {boolean} forzarCierre - Forzar cierre aunque haya errores
 * @returns {Promise<Object>} Resultado del cierre de sesi√≥n
 */
export async function cerrarSesion(forzarCierre = false) {
    try {
        console.log('üîÑ Cerrando sesi√≥n BLINDADA...');
        
        let turnoIdCerrado = null;
        let usuarioEmailCerrado = null;
        const erroresEnCierre = [];
        
        if (currentUser && currentTurno) {
            usuarioEmailCerrado = currentUser.email;
            turnoIdCerrado = currentTurno.idTurno;
            
            try {
                // 1. ‚úÖ CERRAR TURNO EN COLECCI√ìN 'turnos' (CR√çTICO)
                await cerrarTurno(currentTurno.idTurno);
                console.log(`üîí Turno cerrado: ${currentTurno.idTurno}`);
                
            } catch (error) {
                console.error('‚ùå Error cerrando turno:', error);
                erroresEnCierre.push('turno');
                
                if (!forzarCierre) {
                    throw {
                        code: 'auth/close-turno-error',
                        message: 'Error al cerrar el turno activo',
                        originalError: error,
                        detalles: {
                            turnoId: currentTurno.idTurno,
                            usuario: currentUser.email
                        }
                    };
                }
            }

            try {
                // 2. ‚úÖ ACTUALIZAR ESTADO SESI√ìN EN 'usuarion' (CR√çTICO)
                await actualizarEstadoSesionUsuario(currentUser.email, false, '');
                console.log(`üîê Estado de sesi√≥n actualizado: INACTIVA`);
                
            } catch (error) {
                console.error('‚ùå Error actualizando estado de sesi√≥n:', error);
                erroresEnCierre.push('sesion');
                
                if (!forzarCierre) {
                    throw {
                        code: 'auth/session-close-error',
                        message: 'Error al actualizar estado de sesi√≥n',
                        originalError: error
                    };
                }
            }
        }
        
        try {
            // 3. ‚úÖ CERRAR SESI√ìN FIREBASE AUTH
            await signOut(auth);
        } catch (error) {
            console.error('‚ö†Ô∏è Error cerrando sesi√≥n de Firebase:', error);
            erroresEnCierre.push('firebase');
            
            if (!forzarCierre) {
                throw {
                    code: 'auth/firebase-signout-error',
                    message: 'Error cerrando sesi√≥n de Firebase',
                    originalError: error
                };
            }
        }
        
        // 4. ‚úÖ LIMPIAR ESTADO INTERNO (SIEMPRE)
        const usuarioAnterior = currentUser;
        currentUser = null;
        currentTurno = null;
        
        // 5. ‚úÖ DETENER MONITOREO DE SESI√ìN
        detenerMonitoreoSesion();
        
        console.log('‚úÖ SESI√ìN BLINDADA CERRADA correctamente');
        
        // Notificar a los listeners
        notificarCambioAuth(null);
        
        return {
            success: true,
            usuarioAnterior: usuarioAnterior?.email || usuarioEmailCerrado,
            turnoIdCerrado: turnoIdCerrado,
            message: 'Sesi√≥n cerrada correctamente',
            forzado: forzarCierre,
            erroresEnCierre: erroresEnCierre,
            seguridadAplicada: true
        };
        
    } catch (error) {
        console.error('‚ùå Error cerrando sesi√≥n BLINDADA:', error);
        
        // En caso de error, limpiar estado local
        currentUser = null;
        currentTurno = null;
        detenerMonitoreoSesion();
        
        if (error.code) {
            throw error;
        }
        
        throw {
            code: 'auth/signout-error',
            message: 'Error al cerrar sesi√≥n',
            originalError: error
        };
    }
}

/**
 * üõ°Ô∏è NUEVA FUNCI√ìN: Forzar cierre de sesi√≥n (para administradores)
 * @param {string} emailUsuario - Email del usuario a cerrar sesi√≥n
 * @returns {Promise<Object>} Resultado del cierre forzado
 */
export async function forzarCierreSesion(emailUsuario) {
    try {
        validarSesionActiva();
        
        // Solo admin puede hacer esto
        if (!esAdmin()) {
            throw {
                code: 'auth/insufficient-permissions',
                message: 'Solo administradores pueden forzar el cierre de sesiones'
            };
        }

        if (!emailUsuario?.trim()) {
            throw {
                code: 'auth/invalid-email',
                message: 'Email de usuario requerido'
            };
        }
        
        console.log(`üîÑ Forzando cierre de sesi√≥n BLINDADO para: ${emailUsuario}`);
        
        // 1. Limpiar todos los turnos activos del usuario
        const turnosCerrados = await limpiarTurnosHuerfanos(emailUsuario);
        console.log(`üîí ${turnosCerrados} turnos forzados a cerrar`);
        
        // 2. Actualizar estado de sesi√≥n a falso
        await actualizarEstadoSesionUsuario(emailUsuario, false, '');
        console.log(`üîê Sesi√≥n forzada a cerrar para: ${emailUsuario}`);
        
        return {
            success: true,
            usuarioAfectado: emailUsuario,
            turnosCerrados: turnosCerrados,
            message: 'Sesi√≥n cerrada forzadamente por administrador',
            forzadoPor: getCurrentUser()?.email,
            timestamp: new Date().toISOString()
        };
        
    } catch (error) {
        console.error('‚ùå Error forzando cierre de sesi√≥n:', error);
        throw {
            code: 'auth/force-logout-error',
            message: 'Error al forzar el cierre de sesi√≥n',
            originalError: error
        };
    }
}

// === SISTEMA DE MONITOREO DE SESI√ìN ===

/**
 * üõ°Ô∏è Inicia el monitoreo continuo de la sesi√≥n
 */
function iniciarMonitoreoSesion() {
    detenerMonitoreoSesion(); // Limpiar cualquier monitoreo anterior
    
    sessionCheckInterval = setInterval(async () => {
        try {
            if (!currentUser || !currentTurno) {
                detenerMonitoreoSesion();
                return;
            }

            // Verificar integridad de la sesi√≥n
            await verificarIntegridadSesion();
            
        } catch (error) {
            console.error('‚ö†Ô∏è Error en monitoreo de sesi√≥n:', error);
            // No cerrar la sesi√≥n por errores de monitoreo
        }
    }, SESSION_CHECK_INTERVAL);
    
    console.log('üîç Monitoreo de sesi√≥n iniciado');
}

/**
 * Detiene el monitoreo de sesi√≥n
 */
function detenerMonitoreoSesion() {
    if (sessionCheckInterval) {
        clearInterval(sessionCheckInterval);
        sessionCheckInterval = null;
        console.log('üîç Monitoreo de sesi√≥n detenido');
    }
}

/**
 * üõ°Ô∏è Verifica la integridad de la sesi√≥n actual
 * @returns {Promise<boolean>} True si la sesi√≥n es v√°lida
 */
async function verificarIntegridadSesion() {
    try {
        if (!currentUser?.email) {
            throw new Error('No hay usuario actual para verificar');
        }

        // Verificar estado en Firestore
        const userData = await obtenerDatosUsuario(currentUser.email);
        
        if (!userData) {
            throw new Error('Usuario no encontrado en Firestore');
        }

        // Verificar si la sesi√≥n sigue activa en Firestore
        if (!userData.sesionActiva) {
            console.warn('‚ö†Ô∏è Sesi√≥n cerrada externamente, cerrando localmente...');
            await cerrarSesion(true); // Cierre forzado local
            return false;
        }

        // Verificar token de sesi√≥n
        if (userData.sesionToken !== currentUser.sesionToken) {
            console.warn('‚ö†Ô∏è Token de sesi√≥n no coincide, posible sesi√≥n duplicada');
            await cerrarSesion(true); // Cierre forzado
            return false;
        }

        // Verificar turno activo
        if (currentTurno) {
            const turnoActivo = await obtenerTurnoActivo(currentUser.email);
            
            if (!turnoActivo || turnoActivo.idTurno !== currentTurno.idTurno) {
                console.warn('‚ö†Ô∏è Turno no coincide o fue cerrado externamente');
                await cerrarSesion(true); // Cierre forzado
                return false;
            }
        }

        return true;
        
    } catch (error) {
        console.error('‚ùå Error verificando integridad de sesi√≥n:', error);
        return false;
    }
}

// === FUNCIONES DE CONSULTA DE ESTADO ===

/**
 * Obtiene el usuario actual
 * @returns {Object|null} Usuario actual o null
 */
export function getCurrentUser() {
    return currentUser ? { ...currentUser } : null;
}

/**
 * Obtiene el turno actual
 * @returns {Object|null} Turno actual o null
 */
export function getCurrentTurno() {
    return currentTurno ? { ...currentTurno } : null;
}

/**
 * Obtiene el ID del turno actual
 * @returns {string|null} ID del turno actual o null
 */
export function getCurrentTurnoId() {
    return currentTurno?.idTurno || null;
}

/**
 * Verifica si hay una sesi√≥n activa
 * @returns {boolean} True si hay sesi√≥n activa
 */
export function haySesionActiva() {
    return Boolean(currentUser && currentTurno && currentUser.sesionActiva);
}

/**
 * Verifica si el usuario tiene un rol espec√≠fico
 * @param {string} role - Rol a verificar
 * @returns {boolean} True si el usuario tiene el rol
 */
export function tieneRol(role) {
    return currentUser?.role === role;
}

/**
 * Verifica si el usuario es administrador
 * @returns {boolean} True si es administrador
 */
export function esAdmin() {
    return tieneRol(ROLES_USUARIO.ADMIN);
}

// === SISTEMA DE LISTENERS ===

/**
 * Notifica cambios de autenticaci√≥n a los listeners
 * @param {Object|null} user - Usuario actual o null
 */
function notificarCambioAuth(user) {
    authStateListeners.forEach(callback => {
        try {
            callback(user);
        } catch (error) {
            console.error('‚ùå Error en listener de auth:', error);
        }
    });
}

/**
 * Suscribe a cambios de estado de autenticaci√≥n
 * @param {Function} callback - Funci√≥n a ejecutar en cambios
 * @returns {Function} Funci√≥n para desuscribirse
 */
export function suscribirCambiosAuth(callback) {
    if (typeof callback !== 'function') {
        throw new Error('El callback debe ser una funci√≥n');
    }
    
    authStateListeners.push(callback);
    
    // Llamar inmediatamente con el estado actual
    callback(currentUser);
    
    // Retornar funci√≥n para desuscribirse
    return () => {
        const index = authStateListeners.indexOf(callback);
        if (index > -1) {
            authStateListeners.splice(index, 1);
        }
    };
}

// === INICIALIZACI√ìN Y RECUPERACI√ìN DE SESI√ìN ===

/**
 * üõ°Ô∏è Inicializa el m√≥dulo de autenticaci√≥n BLINDADO
 * @returns {Promise<void>}
 */
export async function inicializarAuth() {
    if (isInitialized) {
        console.log('‚ö†Ô∏è M√≥dulo de autenticaci√≥n ya inicializado');
        return;
    }
    
    try {
        console.log('üîÑ Inicializando m√≥dulo de autenticaci√≥n BLINDADO...');
        
        // Listener para cambios de estado de Firebase Auth
        onAuthStateChanged(auth, async (firebaseUser) => {
            try {
                if (firebaseUser && !currentUser) {
                    console.log('üîÑ Detectado usuario autenticado, verificando sesi√≥n...');
                    
                    // Usuario autenticado en Firebase, verificar datos
                    const userData = await obtenerDatosUsuario(firebaseUser.email);
                    
                    if (!userData) {
                        console.warn('‚ö†Ô∏è Usuario no encontrado en Firestore, cerrando sesi√≥n');
                        await signOut(auth);
                        return;
                    }
                    
                    // Verificar si tiene sesi√≥n activa v√°lida
                    if (userData.sesionActiva) {
                        const turnoActivo = await obtenerTurnoActivo(firebaseUser.email);
                        
                        if (turnoActivo) {
                            // Recuperar sesi√≥n v√°lida
                            currentUser = {
                                ...userData,
                                uid: firebaseUser.uid
                            };
                            
                            currentTurno = turnoActivo;
                            
                            // Iniciar monitoreo
                            iniciarMonitoreoSesion();
                            
                            console.log(`‚ôªÔ∏è Sesi√≥n BLINDADA recuperada para: ${firebaseUser.email}`);
                            console.log(`üéØ Turno recuperado: ${turnoActivo.idTurno}`);
                            
                            notificarCambioAuth(currentUser);
                        } else {
                            // Sesi√≥n marcada como activa pero sin turno = inconsistencia
                            console.warn('‚ö†Ô∏è Inconsistencia detectada: sesi√≥n activa sin turno, limpiando...');
                            await actualizarEstadoSesionUsuario(firebaseUser.email, false, '');
                            await signOut(auth);
                        }
                    } else {
                        // Usuario autenticado pero sin sesi√≥n activa = limpiar
                        console.warn('‚ö†Ô∏è Usuario autenticado sin sesi√≥n activa, cerrando...');
                        await signOut(auth);
                    }
                    
                } else if (!firebaseUser && currentUser) {
                    // Usuario cerr√≥ sesi√≥n, limpiar estado
                    console.log('üîÑ Usuario desautenticado, limpiando estado...');
                    currentUser = null;
                    currentTurno = null;
                    detenerMonitoreoSesion();
                    notificarCambioAuth(null);
                }
                
            } catch (error) {
                console.error('‚ùå Error en listener de auth state:', error);
                // En caso de error, limpiar todo
                currentUser = null;
                currentTurno = null;
                detenerMonitoreoSesion();
                notificarCambioAuth(null);
            }
        });
        
        isInitialized = true;
        console.log('‚úÖ M√≥dulo de autenticaci√≥n BLINDADO inicializado');
        
    } catch (error) {
        console.error('‚ùå Error inicializando autenticaci√≥n BLINDADA:', error);
        throw {
            code: 'auth/initialization-error',
            message: 'Error al inicializar el m√≥dulo de autenticaci√≥n',
            originalError: error
        };
    }
}

// === FUNCIONES DE UTILIDAD PARA OTROS M√ìDULOS ===

/**
 * Valida si hay sesi√≥n activa y lanza error si no
 * @throws {Error} Si no hay sesi√≥n activa
 */
export function validarSesionActiva() {
    if (!haySesionActiva()) {
        throw {
            code: 'auth/no-active-session',
            message: 'No hay una sesi√≥n activa'
        };
    }
}

/**
 * Obtiene informaci√≥n completa de la sesi√≥n actual
 * @returns {Object|null} Informaci√≥n de la sesi√≥n
 */
export function getInfoSesion() {
    if (!haySesionActiva()) {
        return null;
    }
    
    return {
        usuario: getCurrentUser(),
        turno: getCurrentTurno(),
        esAdmin: esAdmin(),
        fechaInicio: currentTurno?.fechaInicio,
        tiempoSesion: currentTurno?.fechaInicio ? 
            Date.now() - new Date(currentTurno.fechaInicio).getTime() : 0,
        tokenSesion: currentUser?.sesionToken?.substring(0, 20) + '...',
        monitoreoActivo: Boolean(sessionCheckInterval)
    };
}

/**
 * üõ°Ô∏è Obtiene estad√≠sticas de seguridad de la sesi√≥n
 * @returns {Object} Estad√≠sticas de seguridad
 */
export function getEstadisticasSeguridad() {
    return {
        sesionActiva: haySesionActiva(),
        usuarioActual: currentUser?.email || null,
        turnoActual: currentTurno?.idTurno || null,
        monitoreoActivo: Boolean(sessionCheckInterval),
        roleUsuario: currentUser?.role || null,
        fechaInicioSesion: currentUser?.fechaInicioSesion || null,
        tiempoSesionActiva: currentUser?.fechaInicioSesion ? 
            Date.now() - new Date(currentUser.fechaInicioSesion).getTime() : 0,
        listenersActivos: authStateListeners.length,
        sistemaBlindado: true,
        versionSeguridad: '2.0.0'
    };
}

// === EXPORTACIONES DE CONSTANTES ===
export { ROLES_USUARIO, ESTADOS_TURNO };

// === INICIALIZACI√ìN AUTOM√ÅTICA ===
// Solo en el navegador
if (typeof window !== 'undefined') {
    document.addEventListener('DOMContentLoaded', () => {
        inicializarAuth().catch(error => {
            console.error('‚ùå Error en inicializaci√≥n autom√°tica BLINDADA:', error);
        });
    });
}

// === LOGGING DE DEBUG (SOLO EN DESARROLLO) ===
if (typeof window !== 'undefined' && (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1')) {
    console.group('üõ°Ô∏è Auth Module BLINDADO Debug Info');
    console.log('Auth instance:', auth);
    console.log('DB instance:', db);
    console.log('Roles disponibles:', ROLES_USUARIO);
    console.log('Estados de turno:', ESTADOS_TURNO);
    console.log('Intervalo de verificaci√≥n:', SESSION_CHECK_INTERVAL);
    console.log('Timeout de sesi√≥n:', SESSION_TIMEOUT);
    console.log('Sistema blindado: ACTIVO');
    console.groupEnd();
}












- Archivo 6: JavaScript inventario

// === INVENTARIO.JS - M√ìDULO DE GESTI√ìN DE PRODUCTOS ===

// === IMPORTACIONES REQUERIDAS ===
import { 
    getFirestore, 
    collection, 
    doc, 
    getDoc, 
    getDocs, 
    setDoc, 
    updateDoc, 
    deleteDoc, 
    query, 
    where, 
    orderBy, 
    limit, 
    serverTimestamp 
} from "https://www.gstatic.com/firebasejs/11.6.0/firebase-firestore.js";

import { app } from "./Conexion.js";
import { getCurrentUser, getCurrentTurnoId, validarSesionActiva } from "./Autenticacion.js";

// === INICIALIZACI√ìN DE SERVICIOS ===
const db = getFirestore(app);

// === ESTADO INTERNO DEL M√ìDULO ===
let productosCache = new Map();
let categoriasCache = new Set();
let lastFetchTime = 0;
const CACHE_DURATION = 2 * 60 * 1000; // 2 minutos

// === CONSTANTES DE CONFIGURACI√ìN ===
const STOCK_MINIMO_DEFAULT = 5;
const PRECIO_MINIMO = 0.01;

// === FUNCIONES DE VALIDACI√ìN ===

/**
 * Valida los datos de un producto
 * @param {Object} producto - Datos del producto
 * @returns {Array} Array de errores encontrados
 */
function validarProducto(producto) {
    const errores = [];
    
    if (!producto.nombre?.trim()) {
        errores.push({ field: 'nombre', message: 'El nombre del producto es requerido' });
    }
    
    if (typeof producto.precioVenta !== 'number' || producto.precioVenta < PRECIO_MINIMO) {
        errores.push({ field: 'precioVenta', message: `El precio debe ser mayor a $${PRECIO_MINIMO}` });
    }
    
    if (typeof producto.cantidad !== 'number' || producto.cantidad < 0) {
        errores.push({ field: 'cantidad', message: 'La cantidad debe ser un n√∫mero positivo o cero' });
    }
    
    if (producto.fechaVencimiento && new Date(producto.fechaVencimiento) <= new Date()) {
        errores.push({ field: 'fechaVencimiento', message: 'La fecha de vencimiento debe ser futura' });
    }
    
    return errores;
}

/**
 * Normaliza el nombre del producto para usarlo como ID
 * @param {string} nombre - Nombre del producto
 * @returns {string} Nombre normalizado
 */
function normalizarNombreProducto(nombre) {
    if (typeof nombre !== 'string') return '';
    return nombre.trim(); // üîß CORRECCI√ìN: Mantener nombre original como ID
}

/**
 * Normaliza texto para b√∫squedas
 * @param {string} texto - Texto a normalizar
 * @returns {string} Texto normalizado
 */
function normalizarTexto(texto) {
    if (typeof texto !== 'string') return '';
    return texto
        .toLowerCase()
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g, "")
        .trim();
}

// === FUNCIONES PRINCIPALES DE INVENTARIO ===

/**
 * Obtiene todos los productos del inventario
 * @param {boolean} forceRefresh - Forzar actualizaci√≥n ignorando cach√©
 * @returns {Promise<Array>} Array de productos
 */
export async function obtenerProductos(forceRefresh = false) {
    try {
        // Verificar cach√©
        const now = Date.now();
        if (!forceRefresh && productosCache.size > 0 && (now - lastFetchTime) < CACHE_DURATION) {
            console.log('üì¶ Usando productos desde cach√©');
            return Array.from(productosCache.values());
        }
        
        console.log('üîÑ Obteniendo productos desde Firebase...');
        
        // üîß CORRECCI√ìN: Usar colecci√≥n 'inventario'
        const inventarioRef = collection(db, "inventario");
        const querySnapshot = await getDocs(inventarioRef);
        
        const productos = [];
        productosCache.clear();
        categoriasCache.clear();
        
        querySnapshot.forEach(docSnap => {
            const data = docSnap.data();
            
            // üîß CORRECCI√ìN: ID del documento es el nombre del producto
            const producto = {
                id: docSnap.id, // ID del documento
                nombre: docSnap.id, // Nombre del producto es el ID
                cantidad: parseInt(data.cantidad) || 0,
                precioVenta: parseFloat(data.precioVenta) || 0,
                fechaVencimiento: data.fechaVencimiento || null,
                
                // Campos calculados y auxiliares
                disponible: (parseInt(data.cantidad) || 0) > 0,
                stockBajo: (parseInt(data.cantidad) || 0) <= STOCK_MINIMO_DEFAULT,
                categoria: extraerCategoria(docSnap.id), // Extraer de nombre si aplica
                fechaActualizacion: data.fechaActualizacion || null
            };
            
            productos.push(producto);
            productosCache.set(docSnap.id, producto);
            
            // Actualizar cach√© de categor√≠as
            if (producto.categoria) {
                categoriasCache.add(producto.categoria);
            }
        });
        
        // Ordenar por nombre
        productos.sort((a, b) => a.nombre.localeCompare(b.nombre));
        
        lastFetchTime = now;
        console.log(`‚úÖ Productos obtenidos: ${productos.length}`);
        
        return productos;
        
    } catch (error) {
        console.error('‚ùå Error obteniendo productos:', error);
        throw {
            code: 'inventory/fetch-error',
            message: 'Error al obtener los productos',
            originalError: error
        };
    }
}

/**
 * Busca un producto espec√≠fico por nombre
 * @param {string} nombreProducto - Nombre del producto
 * @returns {Promise<Object|null>} Producto encontrado o null
 */
export async function buscarProductoPorNombre(nombreProducto) {
    try {
        const nombreNormalizado = normalizarNombreProducto(nombreProducto);
        
        if (!nombreNormalizado) {
            return null;
        }
        
        // Verificar cach√© primero
        if (productosCache.has(nombreNormalizado)) {
            return { ...productosCache.get(nombreNormalizado) };
        }
        
        // üîß CORRECCI√ìN: Buscar en colecci√≥n 'inventario' usando nombre como ID
        const productoRef = doc(db, "inventario", nombreNormalizado);
        const productoSnap = await getDoc(productoRef);
        
        if (!productoSnap.exists()) {
            return null;
        }
        
        const data = productoSnap.data();
        const producto = {
            id: productoSnap.id,
            nombre: productoSnap.id, // Nombre es el ID del documento
            cantidad: parseInt(data.cantidad) || 0,
            precioVenta: parseFloat(data.precioVenta) || 0,
            fechaVencimiento: data.fechaVencimiento || null,
            disponible: (parseInt(data.cantidad) || 0) > 0,
            stockBajo: (parseInt(data.cantidad) || 0) <= STOCK_MINIMO_DEFAULT,
            categoria: extraerCategoria(productoSnap.id),
            fechaActualizacion: data.fechaActualizacion || null
        };
        
        // Actualizar cach√©
        productosCache.set(nombreNormalizado, producto);
        
        return producto;
        
    } catch (error) {
        console.error('‚ùå Error buscando producto:', error);
        throw {
            code: 'inventory/search-error',
            message: 'Error al buscar el producto',
            originalError: error
        };
    }
}

/**
 * Busca productos por filtro de texto
 * @param {string} filtro - Texto a buscar
 * @returns {Promise<Array>} Productos encontrados
 */
export async function buscarProductos(filtro) {
    try {
        const productos = await obtenerProductos();
        
        if (!filtro?.trim()) {
            return productos;
        }
        
        const filtroNormalizado = normalizarTexto(filtro);
        
        const productosFiltrados = productos.filter(producto => {
            const nombre = normalizarTexto(producto.nombre);
            const categoria = normalizarTexto(producto.categoria || '');
            
            return nombre.includes(filtroNormalizado) || 
                   categoria.includes(filtroNormalizado);
        });
        
        console.log(`üîç B√∫squeda "${filtro}": ${productosFiltrados.length} productos encontrados`);
        return productosFiltrados;
        
    } catch (error) {
        console.error('‚ùå Error buscando productos:', error);
        throw {
            code: 'inventory/search-error',
            message: 'Error al buscar productos',
            originalError: error
        };
    }
}

/**
 * Crea o actualiza un producto en el inventario
 * @param {Object} datosProducto - Datos del producto
 * @returns {Promise<Object>} Resultado de la operaci√≥n
 */
export async function guardarProducto(datosProducto) {
    try {
        validarSesionActiva();
        
        // Validar datos
        const erroresValidacion = validarProducto(datosProducto);
        if (erroresValidacion.length > 0) {
            throw {
                code: 'validation/invalid-product',
                message: 'Datos del producto inv√°lidos',
                errors: erroresValidacion
            };
        }
        
        const nombreProducto = normalizarNombreProducto(datosProducto.nombre);
        const esActualizacion = productosCache.has(nombreProducto);
        
        // üîß CORRECCI√ìN: Usar nombre como ID del documento
        const productoRef = doc(db, "inventario", nombreProducto);
        
        const datosCompletos = {
            cantidad: parseInt(datosProducto.cantidad) || 0,
            precioVenta: parseFloat(datosProducto.precioVenta),
            fechaVencimiento: datosProducto.fechaVencimiento || null,
            fechaActualizacion: serverTimestamp(),
            actualizadoPor: getCurrentUser()?.email || 'sistema',
            turnoId: getCurrentTurnoId()
        };
        
        // Si es un producto nuevo, agregar fecha de creaci√≥n
        if (!esActualizacion) {
            datosCompletos.fechaCreacion = serverTimestamp();
            datosCompletos.creadoPor = getCurrentUser()?.email || 'sistema';
        }
        
        // Guardar en Firebase
        await setDoc(productoRef, datosCompletos, { merge: true });
        
        // Actualizar cach√©
        const productoCompleto = {
            id: nombreProducto,
            nombre: nombreProducto,
            cantidad: datosCompletos.cantidad,
            precioVenta: datosCompletos.precioVenta,
            fechaVencimiento: datosCompletos.fechaVencimiento,
            disponible: datosCompletos.cantidad > 0,
            stockBajo: datosCompletos.cantidad <= STOCK_MINIMO_DEFAULT,
            categoria: extraerCategoria(nombreProducto),
            fechaActualizacion: new Date().toISOString()
        };
        
        productosCache.set(nombreProducto, productoCompleto);
        
        // Actualizar cach√© de categor√≠as
        if (productoCompleto.categoria) {
            categoriasCache.add(productoCompleto.categoria);
        }
        
        const operacion = esActualizacion ? 'actualizado' : 'creado';
        console.log(`‚úÖ Producto ${operacion}: ${nombreProducto}`);
        
        return {
            success: true,
            producto: productoCompleto,
            operacion,
            message: `Producto ${operacion} correctamente`
        };
        
    } catch (error) {
        console.error('‚ùå Error guardando producto:', error);
        
        if (error.code) {
            throw error;
        }
        
        throw {
            code: 'inventory/save-error',
            message: 'Error al guardar el producto',
            originalError: error
        };
    }
}

/**
 * Actualiza el stock de un producto
 * @param {string} nombreProducto - Nombre del producto
 * @param {number} cantidadVendida - Cantidad a descontar
 * @returns {Promise<Object>} Resultado de la operaci√≥n
 */
export async function actualizarStock(nombreProducto, cantidadVendida) {
    try {
        validarSesionActiva();
        
        const producto = await buscarProductoPorNombre(nombreProducto);
        
        if (!producto) {
            throw {
                code: 'inventory/product-not-found',
                message: 'Producto no encontrado'
            };
        }
        
        if (cantidadVendida <= 0) {
            throw {
                code: 'inventory/invalid-quantity',
                message: 'La cantidad debe ser mayor a cero'
            };
        }
        
        if (producto.cantidad < cantidadVendida) {
            throw {
                code: 'inventory/insufficient-stock',
                message: `Stock insuficiente. Disponible: ${producto.cantidad}, Solicitado: ${cantidadVendida}`,
                disponible: producto.cantidad,
                solicitado: cantidadVendida
            };
        }
        
        const nuevaCantidad = producto.cantidad - cantidadVendida;
        
        // üîß CORRECCI√ìN: Actualizar en colecci√≥n 'inventario'
        const productoRef = doc(db, "inventario", nombreProducto);
        await updateDoc(productoRef, {
            cantidad: nuevaCantidad,
            fechaActualizacion: serverTimestamp(),
            actualizadoPor: getCurrentUser()?.email || 'sistema',
            turnoId: getCurrentTurnoId()
        });
        
        // Actualizar cach√©
        if (productosCache.has(nombreProducto)) {
            const productoEnCache = productosCache.get(nombreProducto);
            productoEnCache.cantidad = nuevaCantidad;
            productoEnCache.disponible = nuevaCantidad > 0;
            productoEnCache.stockBajo = nuevaCantidad <= STOCK_MINIMO_DEFAULT;
            productosCache.set(nombreProducto, productoEnCache);
        }
        
        console.log(`‚úÖ Stock actualizado - ${nombreProducto}: ${producto.cantidad} ‚Üí ${nuevaCantidad}`);
        
        return {
            success: true,
            producto: nombreProducto,
            stockAnterior: producto.cantidad,
            stockNuevo: nuevaCantidad,
            cantidadVendida,
            alertaStockBajo: nuevaCantidad <= STOCK_MINIMO_DEFAULT,
            message: 'Stock actualizado correctamente'
        };
        
    } catch (error) {
        console.error('‚ùå Error actualizando stock:', error);
        
        if (error.code) {
            throw error;
        }
        
        throw {
            code: 'inventory/stock-update-error',
            message: 'Error al actualizar el stock',
            originalError: error
        };
    }
}

/**
 * Elimina un producto del inventario
 * @param {string} nombreProducto - Nombre del producto
 * @returns {Promise<Object>} Resultado de la operaci√≥n
 */
export async function eliminarProducto(nombreProducto) {
    try {
        validarSesionActiva();
        
        const producto = await buscarProductoPorNombre(nombreProducto);
        
        if (!producto) {
            throw {
                code: 'inventory/product-not-found',
                message: 'Producto no encontrado'
            };
        }
        
        // üîß CORRECCI√ìN: Eliminar de colecci√≥n 'inventario'
        const productoRef = doc(db, "inventario", nombreProducto);
        await deleteDoc(productoRef);
        
        // Limpiar cach√©
        productosCache.delete(nombreProducto);
        
        console.log(`üóëÔ∏è Producto eliminado: ${nombreProducto}`);
        
        return {
            success: true,
            producto: nombreProducto,
            message: 'Producto eliminado correctamente'
        };
        
    } catch (error) {
        console.error('‚ùå Error eliminando producto:', error);
        
        if (error.code) {
            throw error;
        }
        
        throw {
            code: 'inventory/delete-error',
            message: 'Error al eliminar el producto',
            originalError: error
        };
    }
}

// === FUNCIONES DE CONSULTA ESPEC√çFICAS ===

/**
 * Obtiene productos con stock bajo
 * @returns {Promise<Array>} Productos con stock bajo
 */
export async function obtenerProductosStockBajo() {
    try {
        const productos = await obtenerProductos();
        return productos.filter(p => p.stockBajo && p.cantidad > 0);
    } catch (error) {
        console.error('‚ùå Error obteniendo productos con stock bajo:', error);
        throw {
            code: 'inventory/low-stock-error',
            message: 'Error al obtener productos con stock bajo',
            originalError: error
        };
    }
}

/**
 * Obtiene productos agotados
 * @returns {Promise<Array>} Productos agotados
 */
export async function obtenerProductosAgotados() {
    try {
        const productos = await obtenerProductos();
        return productos.filter(p => p.cantidad === 0);
    } catch (error) {
        console.error('‚ùå Error obteniendo productos agotados:', error);
        throw {
            code: 'inventory/out-of-stock-error',
            message: 'Error al obtener productos agotados',
            originalError: error
        };
    }
}

/**
 * Obtiene las categor√≠as disponibles
 * @returns {Promise<Array>} Array de categor√≠as
 */
export async function obtenerCategorias() {
    try {
        // Asegurar que los productos est√©n cargados
        await obtenerProductos();
        return Array.from(categoriasCache);
    } catch (error) {
        console.error('‚ùå Error obteniendo categor√≠as:', error);
        throw {
            code: 'inventory/categories-error',
            message: 'Error al obtener las categor√≠as',
            originalError: error
        };
    }
}

/**
 * Obtiene productos por categor√≠a
 * @param {string} categoria - Nombre de la categor√≠a
 * @returns {Promise<Array>} Productos de la categor√≠a
 */
export async function obtenerProductosPorCategoria(categoria) {
    try {
        const productos = await obtenerProductos();
        return productos.filter(p => p.categoria === categoria);
    } catch (error) {
        console.error('‚ùå Error obteniendo productos por categor√≠a:', error);
        throw {
            code: 'inventory/category-products-error',
            message: 'Error al obtener productos de la categor√≠a',
            originalError: error
        };
    }
}

// === FUNCIONES DE UTILIDAD ===

/**
 * Extrae la categor√≠a del nombre del producto (si sigue alguna convenci√≥n)
 * @param {string} nombreProducto - Nombre del producto
 * @returns {string} Categor√≠a extra√≠da o 'General'
 */
function extraerCategoria(nombreProducto) {
    // L√≥gica simple: si el nombre contiene palabras clave, asignar categor√≠a
    const nombre = normalizarTexto(nombreProducto);
    
    if (nombre.includes('coca') || nombre.includes('pepsi') || nombre.includes('sprite') || 
        nombre.includes('jugo') || nombre.includes('agua') || nombre.includes('gaseosa')) {
        return 'Bebidas';
    }
    
    if (nombre.includes('pan') || nombre.includes('galleta') || nombre.includes('torta')) {
        return 'Panader√≠a';
    }
    
    if (nombre.includes('leche') || nombre.includes('queso') || nombre.includes('yogurt')) {
        return 'L√°cteos';
    }
    
    if (nombre.includes('carne') || nombre.includes('pollo') || nombre.includes('pescado')) {
        return 'Carnes';
    }
    
    return 'General';
}

/**
 * Invalida el cach√© de productos
 */
export function invalidarCacheInventario() {
    productosCache.clear();
    categoriasCache.clear();
    lastFetchTime = 0;
    console.log('üóëÔ∏è Cach√© de inventario invalidado');
}

/**
 * Obtiene estad√≠sticas del inventario
 * @returns {Promise<Object>} Estad√≠sticas del inventario
 */
export async function obtenerEstadisticasInventario() {
    try {
        const productos = await obtenerProductos();
        
        const totalProductos = productos.length;
        const productosDisponibles = productos.filter(p => p.disponible).length;
        const productosAgotados = productos.filter(p => !p.disponible).length;
        const productosStockBajo = productos.filter(p => p.stockBajo && p.disponible).length;
        
        const valorTotalInventario = productos.reduce((sum, p) => sum + (p.cantidad * p.precioVenta), 0);
        
        const categorias = Array.from(categoriasCache);
        const estadisticasPorCategoria = {};
        
        categorias.forEach(categoria => {
            const productosCategoria = productos.filter(p => p.categoria === categoria);
            estadisticasPorCategoria[categoria] = {
                total: productosCategoria.length,
                disponibles: productosCategoria.filter(p => p.disponible).length,
                agotados: productosCategoria.filter(p => !p.disponible).length,
                valor: productosCategoria.reduce((sum, p) => sum + (p.cantidad * p.precioVenta), 0)
            };
        });
        
        return {
            totalProductos,
            productosDisponibles,
            productosAgotados,
            productosStockBajo,
            valorTotalInventario,
            totalCategorias: categorias.length,
            estadisticasPorCategoria
        };
        
    } catch (error) {
        console.error('‚ùå Error obteniendo estad√≠sticas:', error);
        throw {
            code: 'inventory/stats-error',
            message: 'Error al obtener estad√≠sticas del inventario',
            originalError: error
        };
    }
}

// === FUNCIONES DE COMPATIBILIDAD PARA CARRITO ===

/**
 * Verifica disponibilidad de productos para el carrito
 * @param {Array} items - Items del carrito [{nombre, cantidad}]
 * @returns {Promise<Object>} Resultado de verificaci√≥n
 */
export async function verificarDisponibilidadCarrito(items) {
    try {
        const resultados = {
            disponibles: [],
            noDisponibles: [],
            stockInsuficiente: []
        };
        
        for (const item of items) {
            const producto = await buscarProductoPorNombre(item.nombre);
            
            if (!producto) {
                resultados.noDisponibles.push({
                    nombre: item.nombre,
                    motivo: 'Producto no encontrado'
                });
                continue;
            }
            
            if (producto.cantidad < item.cantidad) {
                resultados.stockInsuficiente.push({
                    nombre: item.nombre,
                    solicitado: item.cantidad,
                    disponible: producto.cantidad,
                    motivo: 'Stock insuficiente'
                });
                continue;
            }
            
            resultados.disponibles.push({
                nombre: item.nombre,
                cantidad: item.cantidad,
                precio: producto.precioVenta,
                total: item.cantidad * producto.precioVenta
            });
        }
        
        return {
            success: resultados.noDisponibles.length === 0 && resultados.stockInsuficiente.length === 0,
            ...resultados
        };
        
    } catch (error) {
        console.error('‚ùå Error verificando disponibilidad:', error);
        throw {
            code: 'inventory/availability-check-error',
            message: 'Error al verificar disponibilidad',
            originalError: error
        };
    }
}

// === LOGGING DE DEBUG (SOLO EN DESARROLLO) ===
if (typeof window !== 'undefined' && (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1')) {
    console.group('üì¶ Inventory Module Debug Info');
    console.log('DB instance:', db);
    console.log('Cache duration:', CACHE_DURATION, 'ms');
    console.log('Stock m√≠nimo default:', STOCK_MINIMO_DEFAULT);
    console.log('Precio m√≠nimo:', PRECIO_MINIMO);
    console.groupEnd();
}

















- Archivo 7: JavaScript ventasapp

// === VENTASAPP.JS - M√ìDULO DE GESTI√ìN DE VENTAS ===

// === IMPORTACIONES REQUERIDAS ===
import { 
    getFirestore, 
    collection, 
    doc, 
    getDoc, 
    getDocs, 
    setDoc, 
    updateDoc, 
    deleteDoc, 
    query, 
    where, 
    orderBy, 
    limit, 
    serverTimestamp 
} from "https://www.gstatic.com/firebasejs/11.6.0/firebase-firestore.js";

import { app } from "./Conexion.js";
import { getCurrentUser, getCurrentTurno, getCurrentTurnoId, validarSesionActiva } from "./Autenticacion.js";
import { actualizarStock } from "./Inventario.js";

// === INICIALIZACI√ìN DE SERVICIOS ===
const db = getFirestore(app);

// === ESTADO INTERNO DEL M√ìDULO ===
let ventasTurnoCache = new Map();
let estadisticasCache = null;
let lastFetchTime = 0;
const CACHE_DURATION = 1 * 60 * 1000; // 1 minuto

// === CONSTANTES DE CONFIGURACI√ìN ===
const TIPOS_VENTA = {
    EFECTIVO: 'efectivo',
    TARJETA: 'tarjeta',
    TRANSFERENCIA: 'transferencia',
    CHEQUE: 'cheque',
    CREDITO: 'credito'
};

const ESTADOS_VENTA = {
    COMPLETADA: 'completada',
    CANCELADA: 'cancelada',
    PENDIENTE: 'pendiente'
};

// === FUNCIONES DE VALIDACI√ìN ===

/**
 * Valida los datos de una venta
 * @param {Object} datosVenta - Datos de la venta
 * @returns {Array} Array de errores encontrados
 */
function validarVenta(datosVenta) {
    const errores = [];
    
    if (!datosVenta.cliente?.trim()) {
        errores.push({ field: 'cliente', message: 'El nombre del cliente es requerido' });
    }
    
    if (!Array.isArray(datosVenta.productos) || datosVenta.productos.length === 0) {
        errores.push({ field: 'productos', message: 'Debe incluir al menos un producto' });
    }
    
    if (!datosVenta.tipoVenta || !Object.values(TIPOS_VENTA).includes(datosVenta.tipoVenta)) {
        errores.push({ field: 'tipoVenta', message: 'Tipo de venta inv√°lido' });
    }
    
    if (typeof datosVenta.total !== 'number' || datosVenta.total <= 0) {
        errores.push({ field: 'total', message: 'El total debe ser un n√∫mero positivo' });
    }
    
    // Validar productos
    if (Array.isArray(datosVenta.productos)) {
        datosVenta.productos.forEach((producto, index) => {
            if (!producto.nombre?.trim()) {
                errores.push({ field: `productos[${index}].nombre`, message: 'Nombre del producto requerido' });
            }
            
            if (typeof producto.cantidad !== 'number' || producto.cantidad <= 0) {
                errores.push({ field: `productos[${index}].cantidad`, message: 'Cantidad debe ser positiva' });
            }
            
            if (typeof producto.precioVenta !== 'number' || producto.precioVenta <= 0) {
                errores.push({ field: `productos[${index}].precioVenta`, message: 'Precio debe ser positivo' });
            }
        });
    }
    
    return errores;
}

/**
 * Calcula el total de una venta
 * @param {Array} productos - Array de productos
 * @returns {number} Total calculado
 */
function calcularTotalVenta(productos) {
    return productos.reduce((total, producto) => {
        return total + (producto.cantidad * producto.precioVenta);
    }, 0);
}

// === FUNCIONES PRINCIPALES DE VENTAS ===

/**
 * Registra una nueva venta
 * @param {Object} datosVenta - Datos de la venta
 * @returns {Promise<Object>} Resultado de la operaci√≥n
 */
export async function registrarVenta(datosVenta) {
    try {
        validarSesionActiva();
        
        // Validar datos
        const erroresValidacion = validarVenta(datosVenta);
        if (erroresValidacion.length > 0) {
            throw {
                code: 'validation/invalid-sale',
                message: 'Datos de la venta inv√°lidos',
                errors: erroresValidacion
            };
        }
        
        const turnoActual = getCurrentTurno();
        const usuarioActual = getCurrentUser();
        
        if (!turnoActual) {
            throw {
                code: 'sales/no-active-turno',
                message: 'No hay un turno activo'
            };
        }
        
        // Calcular total
        const totalCalculado = calcularTotalVenta(datosVenta.productos);
        
        if (Math.abs(totalCalculado - datosVenta.total) > 0.01) {
            console.warn(`‚ö†Ô∏è Diferencia en total: Calculado=${totalCalculado}, Enviado=${datosVenta.total}`);
        }
        
        console.log(`üîÑ Registrando venta para cliente: ${datosVenta.cliente}`);
        
        // Preparar datos de la venta
        const ventaCompleta = {
            cliente: datosVenta.cliente.trim(),
            productos: datosVenta.productos.map(p => ({
                nombre: p.nombre.trim(),
                cantidad: parseInt(p.cantidad),
                precioVenta: parseFloat(p.precioVenta),
                total: parseInt(p.cantidad) * parseFloat(p.precioVenta)
            })),
            tipoVenta: datosVenta.tipoVenta,
            total: parseFloat(datosVenta.total),
            fechaVenta: serverTimestamp(),
            turnoId: turnoActual.idTurno,
            usuario: usuarioActual.email,
            estado: ESTADOS_VENTA.COMPLETADA
        };
        
        // Actualizar stock de productos
        for (const producto of ventaCompleta.productos) {
            try {
                await actualizarStock(producto.nombre, producto.cantidad);
                console.log(`‚úÖ Stock actualizado: ${producto.nombre} (-${producto.cantidad})`);
            } catch (error) {
                console.error(`‚ùå Error actualizando stock de ${producto.nombre}:`, error);
                // Continuar con otros productos aunque uno falle
            }
        }
        
        // Guardar venta en cuentasCerradas
        await guardarVentaEnCuentasCerradas(turnoActual.idTurno, ventaCompleta);
        
        // Invalidar cach√©
        invalidarCacheVentas();
        
        console.log(`‚úÖ Venta registrada: ${datosVenta.cliente} - $${datosVenta.total}`);
        
        return {
            success: true,
            venta: ventaCompleta,
            turnoId: turnoActual.idTurno,
            message: 'Venta registrada correctamente'
        };
        
    } catch (error) {
        console.error('‚ùå Error registrando venta:', error);
        
        if (error.code) {
            throw error;
        }
        
        throw {
            code: 'sales/registration-error',
            message: 'Error al registrar la venta',
            originalError: error
        };
    }
}

/**
 * Guarda una venta en la colecci√≥n cuentasCerradas
 * @param {string} idTurno - ID del turno
 * @param {Object} venta - Datos de la venta
 * @returns {Promise<void>}
 */
async function guardarVentaEnCuentasCerradas(idTurno, venta) {
    try {
        // üîß CORRECCI√ìN: Usar colecci√≥n 'cuentasCerradas' con idTurno como ID
        const cuentaCerradaRef = doc(db, "cuentasCerradas", idTurno);
        const cuentaCerradaSnap = await getDoc(cuentaCerradaRef);
        
        let datosCuentaCerrada;
        
        if (cuentaCerradaSnap.exists()) {
            // El documento ya existe, agregar la nueva venta al array de clientes
            datosCuentaCerrada = cuentaCerradaSnap.data();
            
            if (!Array.isArray(datosCuentaCerrada.cliente)) {
                datosCuentaCerrada.cliente = [];
            }
            
            // Buscar si ya existe el cliente
            const indiceClienteExistente = datosCuentaCerrada.cliente.findIndex(
                c => c.nombre === venta.cliente
            );
            
            if (indiceClienteExistente !== -1) {
                // Cliente existe, agregar productos a su venta
                const clienteExistente = datosCuentaCerrada.cliente[indiceClienteExistente];
                
                // Agregar productos
                if (!Array.isArray(clienteExistente.productos)) {
                    clienteExistente.productos = [];
                }
                
                venta.productos.forEach(producto => {
                    clienteExistente.productos.push(producto);
                });
                
                // Actualizar total
                clienteExistente.total = (clienteExistente.total || 0) + venta.total;
                
            } else {
                // Cliente nuevo, agregar al array
                datosCuentaCerrada.cliente.push({
                    nombre: venta.cliente,
                    productos: [...venta.productos],
                    tipoVenta: venta.tipoVenta,
                    total: venta.total
                });
            }
            
        } else {
            // üîß CORRECCI√ìN: Crear documento con estructura seg√∫n base de datos
            datosCuentaCerrada = {
                cliente: [{
                    nombre: venta.cliente,
                    productos: [...venta.productos],
                    tipoVenta: venta.tipoVenta,
                    total: venta.total
                }],
                fechaCreacion: serverTimestamp(),
                turnoId: idTurno
            };
        }
        
        // Actualizar fecha de √∫ltima modificaci√≥n
        datosCuentaCerrada.fechaUltimaModificacion = serverTimestamp();
        
        // Guardar en Firebase
        await setDoc(cuentaCerradaRef, datosCuentaCerrada);
        
        console.log(`‚úÖ Venta guardada en cuentasCerradas: ${idTurno}`);
        
    } catch (error) {
        console.error('‚ùå Error guardando venta en cuentasCerradas:', error);
        throw {
            code: 'sales/save-closed-account-error',
            message: 'Error al guardar en cuentas cerradas',
            originalError: error
        };
    }
}

/**
 * Obtiene las ventas del turno actual
 * @param {string} idTurno - ID del turno (opcional, usa el actual si no se especifica)
 * @returns {Promise<Array>} Array de ventas del turno
 */
export async function obtenerVentasTurno(idTurno = null) {
    try {
        const turnoId = idTurno || getCurrentTurnoId();
        
        if (!turnoId) {
            throw {
                code: 'sales/no-turno-id',
                message: 'No hay un turno activo'
            };
        }
        
        // Verificar cach√©
        const now = Date.now();
        if (ventasTurnoCache.has(turnoId) && (now - lastFetchTime) < CACHE_DURATION) {
            console.log('üí∞ Usando ventas desde cach√©');
            return [...ventasTurnoCache.get(turnoId)];
        }
        
        console.log(`üîÑ Obteniendo ventas del turno: ${turnoId}`);
        
        // üîß CORRECCI√ìN: Buscar en colecci√≥n 'cuentasCerradas'
        const cuentaCerradaRef = doc(db, "cuentasCerradas", turnoId);
        const cuentaCerradaSnap = await getDoc(cuentaCerradaRef);
        
        const ventas = [];
        
        if (cuentaCerradaSnap.exists()) {
            const data = cuentaCerradaSnap.data();
            
            if (Array.isArray(data.cliente)) {
                data.cliente.forEach((cliente, index) => {
                    ventas.push({
                        id: `${turnoId}_${index}`,
                        cliente: cliente.nombre || 'Cliente sin nombre',
                        productos: cliente.productos || [],
                        tipoVenta: cliente.tipoVenta || TIPOS_VENTA.EFECTIVO,
                        total: cliente.total || 0,
                        fechaVenta: data.fechaCreacion || null,
                        turnoId: turnoId,
                        estado: ESTADOS_VENTA.COMPLETADA
                    });
                });
            }
        }
        
        // Actualizar cach√©
        ventasTurnoCache.set(turnoId, ventas);
        lastFetchTime = now;
        
        console.log(`‚úÖ Ventas del turno obtenidas: ${ventas.length}`);
        return ventas;
        
    } catch (error) {
        console.error('‚ùå Error obteniendo ventas del turno:', error);
        throw {
            code: 'sales/fetch-turno-error',
            message: 'Error al obtener las ventas del turno',
            originalError: error
        };
    }
}

/**
 * Obtiene el historial de ventas
 * @param {Object} filtros - Filtros de b√∫squeda
 * @returns {Promise<Array>} Array de ventas
 */
export async function obtenerHistorialVentas(filtros = {}) {
    try {
        console.log('üîÑ Obteniendo historial de ventas...');
        
        // üîß CORRECCI√ìN: Consultar colecci√≥n 'cuentasCerradas'
        const cuentasCerradasRef = collection(db, "cuentasCerradas");
        let q = query(cuentasCerradasRef, orderBy("fechaCreacion", "desc"));
        
        if (filtros.limite) {
            q = query(cuentasCerradasRef, orderBy("fechaCreacion", "desc"), limit(filtros.limite));
        }
        
        const querySnapshot = await getDocs(q);
        
        const todasLasVentas = [];
        
        querySnapshot.forEach(docSnap => {
            const data = docSnap.data();
            const turnoId = docSnap.id;
            
            if (Array.isArray(data.cliente)) {
                data.cliente.forEach((cliente, index) => {
                    todasLasVentas.push({
                        id: `${turnoId}_${index}`,
                        cliente: cliente.nombre || 'Cliente sin nombre',
                        productos: cliente.productos || [],
                        tipoVenta: cliente.tipoVenta || TIPOS_VENTA.EFECTIVO,
                        total: cliente.total || 0,
                        fechaVenta: data.fechaCreacion || null,
                        turnoId: turnoId,
                        estado: ESTADOS_VENTA.COMPLETADA
                    });
                });
            }
        });
        
        // Aplicar filtros adicionales si existen
        let ventasFiltradas = todasLasVentas;
        
        if (filtros.cliente) {
            const clienteFiltro = filtros.cliente.toLowerCase();
            ventasFiltradas = ventasFiltradas.filter(v => 
                v.cliente.toLowerCase().includes(clienteFiltro)
            );
        }
        
        if (filtros.tipoVenta) {
            ventasFiltradas = ventasFiltradas.filter(v => v.tipoVenta === filtros.tipoVenta);
        }
        
        if (filtros.fechaDesde) {
            const fechaDesde = new Date(filtros.fechaDesde);
            ventasFiltradas = ventasFiltradas.filter(v => {
                const fechaVenta = v.fechaVenta?.toDate ? v.fechaVenta.toDate() : new Date(v.fechaVenta);
                return fechaVenta >= fechaDesde;
            });
        }
        
        if (filtros.fechaHasta) {
            const fechaHasta = new Date(filtros.fechaHasta);
            ventasFiltradas = ventasFiltradas.filter(v => {
                const fechaVenta = v.fechaVenta?.toDate ? v.fechaVenta.toDate() : new Date(v.fechaVenta);
                return fechaVenta <= fechaHasta;
            });
        }
        
        console.log(`‚úÖ Historial de ventas obtenido: ${ventasFiltradas.length} ventas`);
        return ventasFiltradas;
        
    } catch (error) {
        console.error('‚ùå Error obteniendo historial de ventas:', error);
        throw {
            code: 'sales/history-error',
            message: 'Error al obtener el historial de ventas',
            originalError: error
        };
    }
}

/**
 * Obtiene estad√≠sticas de ventas
 * @param {string} idTurno - ID del turno (opcional)
 * @returns {Promise<Object>} Estad√≠sticas de ventas
 */
export async function obtenerEstadisticasVentas(idTurno = null) {
    try {
        const turnoId = idTurno || getCurrentTurnoId();
        
        // Verificar cach√© de estad√≠sticas
        const now = Date.now();
        if (estadisticasCache && (now - lastFetchTime) < CACHE_DURATION) {
            console.log('üìä Usando estad√≠sticas desde cach√©');
            return { ...estadisticasCache };
        }
        
        console.log('üîÑ Calculando estad√≠sticas de ventas...');
        
        const ventas = turnoId ? 
            await obtenerVentasTurno(turnoId) : 
            await obtenerHistorialVentas({ limite: 100 });
        
        // C√°lculos generales
        const totalVentas = ventas.length;
        const montoTotalVentas = ventas.reduce((sum, v) => sum + v.total, 0);
        const promedioVenta = totalVentas > 0 ? montoTotalVentas / totalVentas : 0;
        
        // Estad√≠sticas por tipo de venta
        const ventasPorTipo = {};
        Object.values(TIPOS_VENTA).forEach(tipo => {
            const ventasTipo = ventas.filter(v => v.tipoVenta === tipo);
            ventasPorTipo[tipo] = {
                cantidad: ventasTipo.length,
                monto: ventasTipo.reduce((sum, v) => sum + v.total, 0),
                porcentaje: totalVentas > 0 ? (ventasTipo.length / totalVentas) * 100 : 0
            };
        });
        
        // Productos m√°s vendidos
        const productosVendidos = {};
        ventas.forEach(venta => {
            venta.productos.forEach(producto => {
                if (!productosVendidos[producto.nombre]) {
                    productosVendidos[producto.nombre] = {
                        nombre: producto.nombre,
                        cantidadVendida: 0,
                        montoTotal: 0,
                        vecesVendido: 0
                    };
                }
                
                productosVendidos[producto.nombre].cantidadVendida += producto.cantidad;
                productosVendidos[producto.nombre].montoTotal += producto.total;
                productosVendidos[producto.nombre].vecesVendido++;
            });
        });
        
        const topProductos = Object.values(productosVendidos)
            .sort((a, b) => b.cantidadVendida - a.cantidadVendida)
            .slice(0, 10);
        
        // Clientes frecuentes
        const clientesFrecuentes = {};
        ventas.forEach(venta => {
            if (!clientesFrecuentes[venta.cliente]) {
                clientesFrecuentes[venta.cliente] = {
                    nombre: venta.cliente,
                    compras: 0,
                    montoTotal: 0
                };
            }
            
            clientesFrecuentes[venta.cliente].compras++;
            clientesFrecuentes[venta.cliente].montoTotal += venta.total;
        });
        
        const topClientes = Object.values(clientesFrecuentes)
            .sort((a, b) => b.compras - a.compras)
            .slice(0, 10);
        
        const estadisticas = {
            resumen: {
                totalVentas,
                montoTotalVentas,
                promedioVenta,
                fechaActualizacion: new Date().toISOString()
            },
            ventasPorTipo,
            topProductos,
            topClientes,
            turnoId: turnoId
        };
        
        // Actualizar cach√©
        estadisticasCache = estadisticas;
        lastFetchTime = now;
        
        console.log(`‚úÖ Estad√≠sticas calculadas - ${totalVentas} ventas, $${montoTotalVentas.toFixed(2)} total`);
        return estadisticas;
        
    } catch (error) {
        console.error('‚ùå Error obteniendo estad√≠sticas:', error);
        throw {
            code: 'sales/stats-error',
            message: 'Error al obtener estad√≠sticas de ventas',
            originalError: error
        };
    }
}

/**
 * Cancela una venta
 * @param {string} ventaId - ID de la venta
 * @param {string} motivo - Motivo de cancelaci√≥n
 * @returns {Promise<Object>} Resultado de la operaci√≥n
 */
export async function cancelarVenta(ventaId, motivo = '') {
    try {
        validarSesionActiva();
        
        // En este sistema, las ventas est√°n consolidadas en cuentasCerradas
        // La cancelaci√≥n requerir√≠a una l√≥gica m√°s compleja
        console.warn('‚ö†Ô∏è Cancelaci√≥n de ventas no implementada completamente');
        
        throw {
            code: 'sales/cancellation-not-implemented',
            message: 'La cancelaci√≥n de ventas no est√° implementada en esta versi√≥n'
        };
        
    } catch (error) {
        console.error('‚ùå Error cancelando venta:', error);
        
        if (error.code) {
            throw error;
        }
        
        throw {
            code: 'sales/cancellation-error',
            message: 'Error al cancelar la venta',
            originalError: error
        };
    }
}

// === FUNCIONES DE UTILIDAD ===

/**
 * Invalida todos los caches del m√≥dulo
 */
export function invalidarCacheVentas() {
    ventasTurnoCache.clear();
    estadisticasCache = null;
    lastFetchTime = 0;
    console.log('üóëÔ∏è Cach√© de ventas invalidado');
}

/**
 * Obtiene el resumen del turno actual
 * @returns {Promise<Object>} Resumen del turno
 */
export async function obtenerResumenTurnoActual() {
    try {
        const turnoActual = getCurrentTurno();
        
        if (!turnoActual) {
            throw {
                code: 'sales/no-active-turno',
                message: 'No hay un turno activo'
            };
        }
        
        const ventas = await obtenerVentasTurno(turnoActual.idTurno);
        const estadisticas = await obtenerEstadisticasVentas(turnoActual.idTurno);
        
        return {
            turno: turnoActual,
            totalVentas: ventas.length,
            montoTotal: estadisticas.resumen.montoTotalVentas,
            ventasPorTipo: estadisticas.ventasPorTipo,
            fechaInicio: turnoActual.fechaInicio,
            usuario: getCurrentUser()?.nombre || getCurrentUser()?.email
        };
        
    } catch (error) {
        console.error('‚ùå Error obteniendo resumen del turno:', error);
        throw {
            code: 'sales/turno-summary-error',
            message: 'Error al obtener el resumen del turno',
            originalError: error
        };
    }
}

/**
 * Valida si un usuario puede realizar ventas
 * @returns {Promise<boolean>} True si puede realizar ventas
 */
export async function puedeRealizarVentas() {
    try {
        const usuario = getCurrentUser();
        const turno = getCurrentTurno();
        
        if (!usuario || !turno) {
            return false;
        }
        
        // üîß CORRECCI√ìN: Verificar usuario en colecci√≥n 'usuarion'
        const userRef = doc(db, "usuarion", usuario.email);
        const userSnap = await getDoc(userRef);
        
        if (!userSnap.exists()) {
            return false;
        }
        
        const userData = userSnap.data();
        return userData.sesionActiva === true;
        
    } catch (error) {
        console.error('‚ùå Error validando permisos de venta:', error);
        return false;
    }
}

// === FUNCIONES DE COMPATIBILIDAD ===

/**
 * Funci√≥n de compatibilidad para c√≥digo existente
 * @deprecated Usar registrarVenta en su lugar
 */
export async function procesarVenta(datosVenta) {
    console.warn('‚ö†Ô∏è procesarVenta() est√° deprecada, usa registrarVenta()');
    return await registrarVenta(datosVenta);
}

/**
 * Funci√≥n de compatibilidad para c√≥digo existente
 * @deprecated Usar obtenerVentasTurno en su lugar
 */
export async function cargarVentas(turnoId) {
    console.warn('‚ö†Ô∏è cargarVentas() est√° deprecada, usa obtenerVentasTurno()');
    return await obtenerVentasTurno(turnoId);
}

// === EXPORTACIONES DE CONSTANTES ===
export { TIPOS_VENTA, ESTADOS_VENTA };

// === LOGGING DE DEBUG (SOLO EN DESARROLLO) ===
if (typeof window !== 'undefined' && (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1')) {
    console.group('üí∞ Sales Module Debug Info');
    console.log('DB instance:', db);
    console.log('Tipos de venta:', TIPOS_VENTA);
    console.log('Estados de venta:', ESTADOS_VENTA);
    console.log('Cache duration:', CACHE_DURATION, 'ms');
    console.groupEnd();
}


















- Archivo 8: JavaScript carritocompras

// === IMPORTACIONES REQUERIDAS ===
import { buscarProductoPorId, verificarDisponibilidad } from "./Inventario.js";

// === ESTADO INTERNO DEL M√ìDULO ===
let carritoInterno = new Map(); // Usar Map para mejor performance
let carritoId = null;
let configuracionCarrito = {
    aplicarIVA: true,
    porcentajeIVA: 0.19,
    aplicarDescuentos: true,
    maxItemsPorProducto: 1000,
    persistirEnLocalStorage: true
};

// === CONSTANTES ===
const EVENTOS_CARRITO = {
    ITEM_AGREGADO: 'item_agregado',
    ITEM_ACTUALIZADO: 'item_actualizado', 
    ITEM_ELIMINADO: 'item_eliminado',
    CARRITO_VACIADO: 'carrito_vaciado',
    TOTAL_ACTUALIZADO: 'total_actualizado'
};

const STORAGE_KEY = 'pos_carrito_actual';

// === FUNCIONES DE VALIDACI√ìN ===
function validarProductoParaCarrito(producto) {
    const errores = [];
    
    if (!producto) {
        errores.push({ field: 'producto', message: 'Producto requerido' });
        return errores;
    }
    
    if (!producto.id) {
        errores.push({ field: 'id', message: 'ID del producto requerido' });
    }
    
    if (!producto.nombre?.trim()) {
        errores.push({ field: 'nombre', message: 'Nombre del producto requerido' });
    }
    
    if (typeof producto.precio !== 'number' || producto.precio < 0) {
        errores.push({ field: 'precio', message: 'Precio inv√°lido' });
    }
    
    return errores;
}

function validarCantidad(cantidad) {
    if (typeof cantidad !== 'number' || cantidad <= 0) {
        return { valid: false, message: 'La cantidad debe ser un n√∫mero positivo' };
    }
    
    if (!Number.isInteger(cantidad)) {
        return { valid: false, message: 'La cantidad debe ser un n√∫mero entero' };
    }
    
    if (cantidad > configuracionCarrito.maxItemsPorProducto) {
        return { 
            valid: false, 
            message: `Cantidad m√°xima permitida: ${configuracionCarrito.maxItemsPorProducto}` 
        };
    }
    
    return { valid: true };
}

// === FUNCIONES DE C√ÅLCULO ===
function calcularSubtotalItem(precio, cantidad) {
    return Math.round(precio * cantidad * 100) / 100;
}

function calcularTotalesCarrito() {
    let subtotal = 0;
    let cantidadTotal = 0;
    
    carritoInterno.forEach(item => {
        subtotal += calcularSubtotalItem(item.precio, item.cantidad);
        cantidadTotal += item.cantidad;
    });
    
    const iva = configuracionCarrito.aplicarIVA ? 
        Math.round(subtotal * configuracionCarrito.porcentajeIVA * 100) / 100 : 0;
    
    const total = Math.round((subtotal + iva) * 100) / 100;
    
    return {
        subtotal,
        iva,
        total,
        cantidadTotal,
        cantidadItems: carritoInterno.size
    };
}

// === FUNCIONES DE PERSISTENCIA ===
function guardarEnLocalStorage() {
    if (!configuracionCarrito.persistirEnLocalStorage) return;
    
    try {
        const carritoData = {
            id: carritoId,
            items: Array.from(carritoInterno.entries()).map(([id, item]) => [id, item]),
            timestamp: Date.now(),
            version: '1.0'
        };
        
        localStorage.setItem(STORAGE_KEY, JSON.stringify(carritoData));
        console.log('üíæ Carrito guardado en localStorage');
    } catch (error) {
        console.error('‚ùå Error guardando carrito en localStorage:', error);
    }
}

function cargarDesdeLocalStorage() {
    if (!configuracionCarrito.persistirEnLocalStorage) return false;
    
    try {
        const stored = localStorage.getItem(STORAGE_KEY);
        if (!stored) return false;
        
        const carritoData = JSON.parse(stored);
        
        // Verificar versi√≥n y validez
        if (!carritoData.version || !carritoData.items) {
            console.warn('‚ö†Ô∏è Formato de carrito en localStorage obsoleto');
            return false;
        }
        
        // Verificar que no sea demasiado antiguo (24 horas)
        const horasTranscurridas = (Date.now() - carritoData.timestamp) / (1000 * 60 * 60);
        if (horasTranscurridas > 24) {
            console.warn('‚ö†Ô∏è Carrito en localStorage demasiado antiguo, se descarta');
            localStorage.removeItem(STORAGE_KEY);
            return false;
        }
        
        // Restaurar datos
        carritoId = carritoData.id;
        carritoInterno.clear();
        
        carritoData.items.forEach(([id, item]) => {
            carritoInterno.set(id, item);
        });
        
        console.log('üì¶ Carrito restaurado desde localStorage');
        return true;
        
    } catch (error) {
        console.error('‚ùå Error cargando carrito desde localStorage:', error);
        localStorage.removeItem(STORAGE_KEY);
        return false;
    }
}

function limpiarLocalStorage() {
    try {
        localStorage.removeItem(STORAGE_KEY);
        console.log('üóëÔ∏è Carrito eliminado de localStorage');
    } catch (error) {
        console.error('‚ùå Error limpiando localStorage:', error);
    }
}

// === FUNCIONES PRINCIPALES DEL CARRITO ===

/**
 * Inicializa el carrito
 * @param {Object} config - Configuraci√≥n opcional
 * @returns {Object} Estado inicial del carrito
 */
export function inicializarCarrito(config = {}) {
    // Aplicar configuraci√≥n personalizada
    configuracionCarrito = { ...configuracionCarrito, ...config };
    
    // Generar ID √∫nico para el carrito
    carritoId = `carrito_${Date.now()}_${Math.random().toString(36).substring(2)}`;
    
    // Intentar cargar carrito previo
    const cargado = cargarDesdeLocalStorage();
    
    if (!cargado) {
        carritoInterno.clear();
    }
    
    console.log('üõí Carrito inicializado:', carritoId);
    
    return obtenerEstadoCarrito();
}

/**
 * Agrega un producto al carrito
 * @param {string} productId - ID del producto
 * @param {number} cantidad - Cantidad a agregar
 * @param {Object} opciones - Opciones adicionales
 * @returns {Promise<Object>} Resultado de la operaci√≥n
 */
export async function agregarAlCarrito(productId, cantidad = 1, opciones = {}) {
    try {
        // Validar cantidad
        const validacionCantidad = validarCantidad(cantidad);
        if (!validacionCantidad.valid) {
            throw {
                code: 'validation/invalid-quantity',
                message: validacionCantidad.message
            };
        }
        
        // Obtener informaci√≥n del producto
        const producto = await buscarProductoPorId(productId);
        if (!producto) {
            throw {
                code: 'product/not-found',
                message: 'Producto no encontrado'
            };
        }
        
        // Validar producto
        const erroresProducto = validarProductoParaCarrito(producto);
        if (erroresProducto.length > 0) {
            throw {
                code: 'validation/invalid-product',
                message: 'Producto inv√°lido',
                errors: erroresProducto
            };
        }
        
        // Verificar disponibilidad si no se fuerza
        if (!opciones.forzarAgregar) {
            const cantidadExistente = carritoInterno.has(productId) ? 
                carritoInterno.get(productId).cantidad : 0;
            
            const cantidadTotal = cantidadExistente + cantidad;
            
            const disponibilidad = await verificarDisponibilidad(productId, cantidadTotal);
            if (!disponibilidad.disponible) {
                throw {
                    code: 'inventory/insufficient-stock',
                    message: `Stock insuficiente. Disponible: ${disponibilidad.cantidadDisponible}, En carrito: ${cantidadExistente}, Solicitado: ${cantidad}`,
                    disponibilidad
                };
            }
        }
        
        // Agregar o actualizar item en el carrito
        let itemAnterior = null;
        if (carritoInterno.has(productId)) {
            itemAnterior = { ...carritoInterno.get(productId) };
            const item = carritoInterno.get(productId);
            item.cantidad += cantidad;
            item.subtotal = calcularSubtotalItem(item.precio, item.cantidad);
            item.fechaActualizacion = new Date().toISOString();
        } else {
            const nuevoItem = {
                id: producto.id,
                nombre: producto.nombre,
                precio: producto.precio,
                cantidad: cantidad,
                subtotal: calcularSubtotalItem(producto.precio, cantidad),
                categoria: producto.categoria || 'Sin categor√≠a',
                fechaAgregado: new Date().toISOString(),
                fechaActualizacion: new Date().toISOString()
            };
            carritoInterno.set(productId, nuevoItem);
        }
        
        // Guardar en localStorage
        guardarEnLocalStorage();
        
        // Calcular nuevos totales
        const totales = calcularTotalesCarrito();
        
        const resultado = {
            success: true,
            action: itemAnterior ? 'actualizado' : 'agregado',
            item: { ...carritoInterno.get(productId) },
            itemAnterior,
            cantidadAgregada: cantidad,
            totales,
            message: `${producto.nombre} ${itemAnterior ? 'actualizado en' : 'agregado al'} carrito`
        };
        
        console.log(`‚úÖ Producto ${resultado.action}: ${producto.nombre} (${cantidad})`);
        
        // Emitir evento si hay listeners
        emitirEvento(itemAnterior ? EVENTOS_CARRITO.ITEM_ACTUALIZADO : EVENTOS_CARRITO.ITEM_AGREGADO, resultado);
        
        return resultado;
        
    } catch (error) {
        console.error('‚ùå Error agregando al carrito:', error);
        
        if (error.code) {
            throw error;
        }
        
        throw {
            code: 'cart/add-error',
            message: 'Error al agregar producto al carrito',
            originalError: error
        };
    }
}

/**
 * Actualiza la cantidad de un producto en el carrito
 * @param {string} productId - ID del producto
 * @param {number} nuevaCantidad - Nueva cantidad
 * @param {Object} opciones - Opciones adicionales
 * @returns {Promise<Object>} Resultado de la operaci√≥n
 */
export async function actualizarCantidad(productId, nuevaCantidad, opciones = {}) {
    try {
        if (!carritoInterno.has(productId)) {
            throw {
                code: 'cart/item-not-found',
                message: 'Producto no est√° en el carrito'
            };
        }
        
        // Si la nueva cantidad es 0, eliminar el item
        if (nuevaCantidad === 0) {
            return await eliminarDelCarrito(productId);
        }
        
        // Validar nueva cantidad
        const validacionCantidad = validarCantidad(nuevaCantidad);
        if (!validacionCantidad.valid) {
            throw {
                code: 'validation/invalid-quantity',
                message: validacionCantidad.message
            };
        }
        
        const itemAnterior = { ...carritoInterno.get(productId) };
        
        // Verificar disponibilidad si no se fuerza
        if (!opciones.forzarActualizar) {
            const disponibilidad = await verificarDisponibilidad(productId, nuevaCantidad);
            if (!disponibilidad.disponible) {
                throw {
                    code: 'inventory/insufficient-stock',
                    message: `Stock insuficiente. Disponible: ${disponibilidad.cantidadDisponible}, Solicitado: ${nuevaCantidad}`,
                    disponibilidad
                };
            }
        }
        
        // Actualizar item
        const item = carritoInterno.get(productId);
        item.cantidad = nuevaCantidad;
        item.subtotal = calcularSubtotalItem(item.precio, nuevaCantidad);
        item.fechaActualizacion = new Date().toISOString();
        
        // Guardar en localStorage
        guardarEnLocalStorage();
        
        // Calcular nuevos totales
        const totales = calcularTotalesCarrito();
        
        const resultado = {
            success: true,
            action: 'cantidad_actualizada',
            item: { ...item },
            itemAnterior,
            cantidadAnterior: itemAnterior.cantidad,
            nuevaCantidad,
            diferencia: nuevaCantidad - itemAnterior.cantidad,
            totales,
            message: `Cantidad de ${item.nombre} actualizada`
        };
        
        console.log(`‚úÖ Cantidad actualizada: ${item.nombre} (${itemAnterior.cantidad} ‚Üí ${nuevaCantidad})`);
        
        // Emitir evento
        emitirEvento(EVENTOS_CARRITO.ITEM_ACTUALIZADO, resultado);
        
        return resultado;
        
    } catch (error) {
        console.error('‚ùå Error actualizando cantidad:', error);
        
        if (error.code) {
            throw error;
        }
        
        throw {
            code: 'cart/update-error',
            message: 'Error al actualizar cantidad en el carrito',
            originalError: error
        };
    }
}

/**
 * Elimina un producto del carrito
 * @param {string} productId - ID del producto
 * @returns {Object} Resultado de la operaci√≥n
 */
export function eliminarDelCarrito(productId) {
    try {
        if (!carritoInterno.has(productId)) {
            throw {
                code: 'cart/item-not-found',
                message: 'Producto no est√° en el carrito'
            };
        }
        
        const itemEliminado = { ...carritoInterno.get(productId) };
        carritoInterno.delete(productId);
        
        // Guardar en localStorage
        guardarEnLocalStorage();
        
        // Calcular nuevos totales
        const totales = calcularTotalesCarrito();
        
        const resultado = {
            success: true,
            action: 'eliminado',
            itemEliminado,
            totales,
            message: `${itemEliminado.nombre} eliminado del carrito`
        };
        
        console.log(`üóëÔ∏è Producto eliminado del carrito: ${itemEliminado.nombre}`);
        
        // Emitir evento
        emitirEvento(EVENTOS_CARRITO.ITEM_ELIMINADO, resultado);
        
        return resultado;
        
    } catch (error) {
        console.error('‚ùå Error eliminando del carrito:', error);
        
        if (error.code) {
            throw error;
        }
        
        throw {
            code: 'cart/remove-error',
            message: 'Error al eliminar producto del carrito',
            originalError: error
        };
    }
}

/**
 * Vac√≠a completamente el carrito
 * @returns {Object} Resultado de la operaci√≥n
 */
export function vaciarCarrito() {
    try {
        const itemsAnteriores = Array.from(carritoInterno.values());
        const totalesAnteriores = calcularTotalesCarrito();
        
        carritoInterno.clear();
        limpiarLocalStorage();
        
        const resultado = {
            success: true,
            action: 'vaciado',
            itemsEliminados: itemsAnteriores,
            totalesAnteriores,
            cantidadItemsEliminados: itemsAnteriores.length,
            message: 'Carrito vaciado completamente'
        };
        
        console.log('üóëÔ∏è Carrito vaciado completamente');
        
        // Emitir evento
        emitirEvento(EVENTOS_CARRITO.CARRITO_VACIADO, resultado);
        
        return resultado;
        
    } catch (error) {
        console.error('‚ùå Error vaciando carrito:', error);
        throw {
            code: 'cart/clear-error',
            message: 'Error al vaciar el carrito',
            originalError: error
        };
    }
}

// === FUNCIONES DE CONSULTA ===

/**
 * Obtiene el estado completo del carrito
 * @returns {Object} Estado del carrito
 */
export function obtenerEstadoCarrito() {
    const items = Array.from(carritoInterno.values());
    const totales = calcularTotalesCarrito();
    
    return {
        id: carritoId,
        items,
        totales,
        estaVacio: items.length === 0,
        configuracion: { ...configuracionCarrito },
        timestamp: Date.now()
    };
}

/**
 * Obtiene un item espec√≠fico del carrito
 * @param {string} productId - ID del producto
 * @returns {Object|null} Item del carrito o null si no existe
 */
export function obtenerItemCarrito(productId) {
    if (!carritoInterno.has(productId)) {
        return null;
    }
    
    return { ...carritoInterno.get(productId) };
}

/**
 * Verifica si un producto est√° en el carrito
 * @param {string} productId - ID del producto
 * @returns {boolean} True si est√° en el carrito
 */
export function estaEnCarrito(productId) {
    return carritoInterno.has(productId);
}

/**
 * Obtiene la cantidad de un producto en el carrito
 * @param {string} productId - ID del producto
 * @returns {number} Cantidad del producto (0 si no est√°)
 */
export function obtenerCantidadEnCarrito(productId) {
    if (!carritoInterno.has(productId)) {
        return 0;
    }
    
    return carritoInterno.get(productId).cantidad;
}

/**
 * Obtiene solo los items del carrito (array)
 * @returns {Array} Array de items
 */
export function obtenerItemsCarrito() {
    return Array.from(carritoInterno.values());
}

/**
 * Obtiene solo los totales del carrito
 * @returns {Object} Totales calculados
 */
export function obtenerTotalesCarrito() {
    return calcularTotalesCarrito();
}

// === FUNCIONES DE VALIDACI√ìN Y VERIFICACI√ìN ===

/**
 * Valida todo el carrito antes de procesar venta
 * @returns {Promise<Object>} Resultado de la validaci√≥n
 */
export async function validarCarritoCompleto() {
    try {
        const items = obtenerItemsCarrito();
        
        if (items.length === 0) {
            return {
                valido: false,
                errores: ['El carrito est√° vac√≠o'],
                warnings: []
            };
        }
        
        const errores = [];
        const warnings = [];
        const verificacionesStock = [];
        
        // Verificar cada item
        for (const item of items) {
            // Validar estructura del item
            const erroresItem = validarProductoParaCarrito(item);
            if (erroresItem.length > 0) {
                errores.push(`Producto ${item.nombre || item.id}: ${erroresItem.map(e => e.message).join(', ')}`);
                continue;
            }
            
            // Verificar stock
            try {
                const disponibilidad = await verificarDisponibilidad(item.id, item.cantidad);
                verificacionesStock.push({
                    productId: item.id,
                    nombre: item.nombre,
                    ...disponibilidad
                });
                
                if (!disponibilidad.disponible) {
                    errores.push(`${item.nombre}: Stock insuficiente (disponible: ${disponibilidad.cantidadDisponible}, en carrito: ${item.cantidad})`);
                } else if (disponibilidad.cantidadDisponible < item.cantidad * 2) {
                    warnings.push(`${item.nombre}: Stock bajo (disponible: ${disponibilidad.cantidadDisponible})`);
                }
            } catch (error) {
                errores.push(`${item.nombre}: Error verificando stock - ${error.message}`);
            }
        }
        
        return {
            valido: errores.length === 0,
            errores,
            warnings,
            verificacionesStock,
            resumenValidacion: `${items.length} items validados, ${errores.length} errores, ${warnings.length} advertencias`
        };
        
    } catch (error) {
        console.error('‚ùå Error validando carrito:', error);
        return {
            valido: false,
            errores: ['Error interno validando el carrito'],
            warnings: [],
            error: error.message
        };
    }
}

// === SISTEMA DE EVENTOS ===
const eventListeners = new Map();

/**
 * Suscribe a eventos del carrito
 * @param {string} evento - Nombre del evento
 * @param {Function} callback - Funci√≥n a ejecutar
 * @returns {Function} Funci√≥n para desuscribirse
 */
export function suscribirEventoCarrito(evento, callback) {
    if (!eventListeners.has(evento)) {
        eventListeners.set(evento, new Set());
    }
    
    eventListeners.get(evento).add(callback);
    
    // Retornar funci√≥n para desuscribirse
    return () => {
        const listeners = eventListeners.get(evento);
        if (listeners) {
            listeners.delete(callback);
        }
    };
}

function emitirEvento(evento, data) {
    const listeners = eventListeners.get(evento);
    if (listeners) {
        listeners.forEach(callback => {
            try {
                callback(data);
            } catch (error) {
                console.error(`‚ùå Error en listener de evento ${evento}:`, error);
            }
        });
    }
}

// === FUNCIONES DE UTILIDAD ===

/**
 * Aplica un descuento al total del carrito
 * @param {number} descuento - Monto del descuento
 * @param {string} tipo - Tipo de descuento ('monto' o 'porcentaje')
 * @returns {Object} Totales con descuento aplicado
 */
export function aplicarDescuento(descuento, tipo = 'monto') {
    const totalesBase = calcularTotalesCarrito();
    
    let montoDescuento = 0;
    if (tipo === 'porcentaje') {
        montoDescuento = Math.round(totalesBase.subtotal * (descuento / 100) * 100) / 100;
    } else {
        montoDescuento = Math.round(descuento * 100) / 100;
    }
    
    const totalConDescuento = Math.max(0, totalesBase.total - montoDescuento);
    
    return {
        ...totalesBase,
        descuento: montoDescuento,
        tipoDescuento: tipo,
        totalConDescuento,
        porcentajeDescuento: tipo === 'porcentaje' ? descuento : 
            Math.round((montoDescuento / totalesBase.subtotal) * 100 * 100) / 100
    };
}

/**
 * Exporta el carrito en formato para procesamiento de ventas
 * @returns {Object} Carrito en formato de venta
 */
export function exportarParaVenta() {
    const estado = obtenerEstadoCarrito();
    
    return {
        items: estado.items.map(item => ({
            id: item.id,
            nombre: item.nombre,
            precio: item.precio,
            cantidad: item.cantidad,
            subtotal: item.subtotal
        })),
        totales: estado.totales,
        metadata: {
            carritoId: estado.id,
            fechaExportacion: new Date().toISOString(),
            cantidadItems: estado.totales.cantidadItems
        }
    };
}

// === FUNCIONES DE COMPATIBILIDAD ===
// Para mantener compatibilidad con c√≥digo existente

export function renderCarrito() {
    console.warn('‚ö†Ô∏è renderCarrito() est√° deprecada. Use las nuevas APIs de estado y eventos.');
    return obtenerEstadoCarrito();
}

// Exportar el carrito como propiedad global para compatibilidad
if (typeof window !== 'undefined') {
    Object.defineProperty(window, 'carrito', {
        get: () => {
            console.warn('‚ö†Ô∏è window.carrito est√° deprecado. Use las nuevas APIs del m√≥dulo CarritoCompras.');
            return obtenerItemsCarrito();
        }
    });
}

// === INICIALIZACI√ìN AUTOM√ÅTICA ===
// Inicializar carrito autom√°ticamente cuando se carga el m√≥dulo
if (typeof document !== 'undefined') {
    // Solo en el navegador
    inicializarCarrito();
}

// === EXPORTACIONES DE CONSTANTES ===
export { EVENTOS_CARRITO };

// === LOGGING DE DEBUG (SOLO EN DESARROLLO) ===
if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
    console.group('üõí Shopping Cart Module Debug Info');
    console.log('Carrito ID:', carritoId);
    console.log('Configuraci√≥n:', configuracionCarrito);
    console.log('Eventos disponibles:', EVENTOS_CARRITO);
    console.log('Storage key:', STORAGE_KEY);
    console.groupEnd();
}
















- Archivo 9: JavaScript cuentas

// === CUENTAS.JS - M√ìDULO DE GESTI√ìN DE CUENTAS Y CLIENTES ===

// === IMPORTACIONES REQUERIDAS ===
import { 
    getFirestore, 
    collection, 
    addDoc,
    doc,
    getDoc,
    getDocs,
    setDoc,
    updateDoc,
    deleteDoc,
    query,
    where,
    orderBy,
    limit,
    serverTimestamp
} from "https://www.gstatic.com/firebasejs/11.6.0/firebase-firestore.js";

import { app } from "./Conexion.js";
import { getCurrentUser, getCurrentTurnoId, validarSesionActiva } from "./Autenticacion.js";

// === INICIALIZACI√ìN DE SERVICIOS ===
const db = getFirestore(app);

// === ESTADO INTERNO DEL M√ìDULO ===
let cuentasCache = new Map();
let clientesCache = new Map();
let lastFetchTime = 0;
const CACHE_DURATION = 3 * 60 * 1000; // 3 minutos en millisegundos

// === CONSTANTES DE CONFIGURACI√ìN ===
const ESTADOS_CUENTA = {
    PENDIENTE: 'pendiente',
    PAGADA: 'pagada',
    CANCELADA: 'cancelada',
    VENCIDA: 'vencida'
};

const TIPOS_MOVIMIENTO = {
    VENTA: 'venta',
    PAGO: 'pago',
    AJUSTE: 'ajuste',
    CANCELACION: 'cancelacion'
};

const METODOS_PAGO = {
    EFECTIVO: 'efectivo',
    TARJETA: 'tarjeta',
    TRANSFERENCIA: 'transferencia',
    CHEQUE: 'cheque'
};

// === FUNCIONES DE VALIDACI√ìN ===
function validarCliente(cliente) {
    const errores = [];
    
    if (!cliente.nombre?.trim()) {
        errores.push({ field: 'nombre', message: 'El nombre del cliente es requerido' });
    }
    
    if (cliente.telefono && !/^\d{10}$/.test(cliente.telefono.replace(/\D/g, ''))) {
        errores.push({ field: 'telefono', message: 'Tel√©fono debe tener 10 d√≠gitos' });
    }
    
    if (cliente.email && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(cliente.email)) {
        errores.push({ field: 'email', message: 'Email inv√°lido' });
    }
    
    return errores;
}

function validarCuentaActiva(cuenta) {
    const errores = [];
    
    if (!cuenta.cliente?.trim()) {
        errores.push({ field: 'cliente', message: 'Cliente requerido' });
    }
    
    if (typeof cuenta.total !== 'number' || cuenta.total <= 0) {
        errores.push({ field: 'total', message: 'El total debe ser un n√∫mero positivo' });
    }
    
    if (!Array.isArray(cuenta.productos)) {
        errores.push({ field: 'productos', message: 'Los productos son requeridos' });
    }
    
    return errores;
}

// === FUNCIONES DE NORMALIZACI√ìN ===
function normalizarTexto(texto) {
    if (typeof texto !== 'string') return '';
    return texto
        .toLowerCase()
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g, "")
        .trim();
}

function normalizarTelefono(telefono) {
    return telefono.replace(/\D/g, '');
}

// === GESTI√ìN DE CUENTAS ACTIVAS ===

/**
 * Obtiene todas las cuentas activas (pendientes de pago)
 * @param {boolean} forceRefresh - Forzar actualizaci√≥n ignorando cach√©
 * @returns {Promise<Array>} Array de cuentas activas
 */
export async function obtenerCuentasPendientes(forceRefresh = false) {
    try {
        // Verificar cach√©
        const now = Date.now();
        if (!forceRefresh && cuentasCache.size > 0 && (now - lastFetchTime) < CACHE_DURATION) {
            console.log('üè™ Usando cuentas desde cach√©');
            return Array.from(cuentasCache.values());
        }
        
        console.log('üîÑ Obteniendo cuentas activas desde Firebase...');
        
        // üîß CORRECCI√ìN: Usar colecci√≥n 'cuentasActivas'
        const cuentasActivasRef = collection(db, "cuentasActivas");
        const querySnapshot = await getDocs(cuentasActivasRef);
        
        const cuentas = [];
        cuentasCache.clear();
        
        querySnapshot.forEach(docSnap => {
            const data = docSnap.data();
            
            // üîß CORRECCI√ìN: ID del documento es el nombre del cliente
            const nombreCliente = docSnap.id;
            
            const cuenta = {
                id: docSnap.id, // ID del documento (nombre del cliente)
                clienteId: docSnap.id,
                clienteNombre: nombreCliente,
                cliente: data.cliente || nombreCliente, // Campo cliente o usar ID
                monto: parseFloat(data.total) || 0,
                saldoPendiente: parseFloat(data.total) || 0,
                total: parseFloat(data.total) || 0,
                concepto: 'Consumo en local',
                descripcion: `Cuenta activa de ${nombreCliente}`,
                estado: ESTADOS_CUENTA.PENDIENTE,
                fechaCreacion: data.fechaApertura || data.fechaCreacion || null,
                fechaApertura: data.fechaApertura || null,
                fechaUltimaActualizacion: data.fechaUltimaActualizacion || null,
                fechaVencimiento: null,
                ventaId: null,
                turnoId: data.idTurno || null,
                idTurno: data.idTurno || null,
                tipo: data.tipo || 'Consumo en el local',
                productos: data.productos || {},
                clienteTelefono: data.telefono || ''
            };
            
            cuentas.push(cuenta);
            cuentasCache.set(docSnap.id, cuenta);
        });
        
        // Ordenar por fecha de creaci√≥n (m√°s recientes primero)
        cuentas.sort((a, b) => {
            if (!a.fechaCreacion && !b.fechaCreacion) return 0;
            if (!a.fechaCreacion) return 1;
            if (!b.fechaCreacion) return -1;
            
            const fechaA = a.fechaCreacion.toDate ? a.fechaCreacion.toDate() : new Date(a.fechaCreacion);
            const fechaB = b.fechaCreacion.toDate ? b.fechaCreacion.toDate() : new Date(b.fechaCreacion);
            
            return fechaB - fechaA;
        });
        
        lastFetchTime = now;
        console.log(`‚úÖ Cuentas activas obtenidas: ${cuentas.length}`);
        
        return cuentas;
        
    } catch (error) {
        console.error('‚ùå Error obteniendo cuentas activas:', error);
        throw {
            code: 'accounts/fetch-pending-error',
            message: 'Error al obtener las cuentas activas',
            originalError: error
        };
    }
}

/**
 * Busca una cuenta activa espec√≠fica por nombre del cliente
 * @param {string} nombreCliente - Nombre del cliente
 * @returns {Promise<Object|null>} Cuenta encontrada o null
 */
export async function buscarCuentaPorCliente(nombreCliente) {
    try {
        if (!nombreCliente?.trim()) {
            return null;
        }
        
        // Verificar cach√© primero
        if (cuentasCache.has(nombreCliente)) {
            return { ...cuentasCache.get(nombreCliente) };
        }
        
        // üîß CORRECCI√ìN: Buscar en colecci√≥n 'cuentasActivas' usando nombre como ID
        const cuentaRef = doc(db, "cuentasActivas", nombreCliente);
        const cuentaSnap = await getDoc(cuentaRef);
        
        if (!cuentaSnap.exists()) {
            return null;
        }
        
        const data = cuentaSnap.data();
        const cuenta = {
            id: cuentaSnap.id,
            clienteId: cuentaSnap.id,
            clienteNombre: cuentaSnap.id,
            cliente: data.cliente || cuentaSnap.id,
            monto: parseFloat(data.total) || 0,
            saldoPendiente: parseFloat(data.total) || 0,
            total: parseFloat(data.total) || 0,
            concepto: 'Consumo en local',
            descripcion: `Cuenta activa de ${cuentaSnap.id}`,
            estado: ESTADOS_CUENTA.PENDIENTE,
            fechaCreacion: data.fechaApertura || data.fechaCreacion || null,
            fechaApertura: data.fechaApertura || null,
            fechaUltimaActualizacion: data.fechaUltimaActualizacion || null,
            turnoId: data.idTurno || null,
            idTurno: data.idTurno || null,
            productos: data.productos || {},
            clienteTelefono: data.telefono || ''
        };
        
        // Actualizar cach√©
        cuentasCache.set(nombreCliente, cuenta);
        
        return cuenta;
        
    } catch (error) {
        console.error('‚ùå Error buscando cuenta por cliente:', error);
        throw {
            code: 'accounts/search-error',
            message: 'Error al buscar la cuenta del cliente',
            originalError: error
        };
    }
}

/**
 * Crea o actualiza una cuenta activa
 * @param {Object} datosCuenta - Datos de la cuenta
 * @returns {Promise<Object>} Resultado de la operaci√≥n
 */
export async function crearOActualizarCuentaActiva(datosCuenta) {
    try {
        validarSesionActiva();
        
        // Validar datos
        const erroresValidacion = validarCuentaActiva(datosCuenta);
        if (erroresValidacion.length > 0) {
            throw {
                code: 'validation/invalid-account',
                message: 'Datos de la cuenta inv√°lidos',
                errors: erroresValidacion
            };
        }
        
        const nombreCliente = datosCuenta.cliente.trim();
        
        // üîß CORRECCI√ìN: Usar nombre del cliente como ID del documento
        const cuentaRef = doc(db, "cuentasActivas", nombreCliente);
        const cuentaExistente = await getDoc(cuentaRef);
        
        let datosCuentaCompletos;
        const esActualizacion = cuentaExistente.exists();
        
        if (esActualizacion) {
            // Actualizar cuenta existente
            const datosActuales = cuentaExistente.data();
            
            datosCuentaCompletos = {
                ...datosActuales,
                total: parseFloat(datosCuenta.total),
                productos: datosCuenta.productos || datosActuales.productos || {},
                fechaUltimaActualizacion: serverTimestamp(),
                idTurno: getCurrentTurnoId() || datosActuales.idTurno,
                actualizadoPor: getCurrentUser()?.email || 'sistema'
            };
            
        } else {
            // Crear nueva cuenta activa
            datosCuentaCompletos = {
                cliente: nombreCliente,
                total: parseFloat(datosCuenta.total),
                productos: datosCuenta.productos || {},
                fechaApertura: serverTimestamp(),
                fechaCreacion: serverTimestamp(),
                fechaUltimaActualizacion: serverTimestamp(),
                idTurno: getCurrentTurnoId(),
                tipo: datosCuenta.tipo || 'Consumo en el local',
                telefono: datosCuenta.telefono || '',
                creadoPor: getCurrentUser()?.email || 'sistema'
            };
        }
        
        // Guardar en Firebase
        await setDoc(cuentaRef, datosCuentaCompletos);
        
        // Actualizar cach√©
        const cuentaParaCache = {
            id: nombreCliente,
            clienteId: nombreCliente,
            clienteNombre: nombreCliente,
            cliente: nombreCliente,
            monto: datosCuentaCompletos.total,
            saldoPendiente: datosCuentaCompletos.total,
            total: datosCuentaCompletos.total,
            concepto: 'Consumo en local',
            estado: ESTADOS_CUENTA.PENDIENTE,
            fechaCreacion: esActualizacion ? cuentaExistente.data().fechaCreacion : new Date(),
            fechaApertura: esActualizacion ? cuentaExistente.data().fechaApertura : new Date(),
            fechaUltimaActualizacion: new Date(),
            turnoId: datosCuentaCompletos.idTurno,
            idTurno: datosCuentaCompletos.idTurno,
            productos: datosCuentaCompletos.productos,
            clienteTelefono: datosCuentaCompletos.telefono
        };
        
        cuentasCache.set(nombreCliente, cuentaParaCache);
        
        const operacion = esActualizacion ? 'actualizada' : 'creada';
        console.log(`‚úÖ Cuenta ${operacion}: ${nombreCliente} - $${datosCuenta.total}`);
        
        return {
            success: true,
            cuentaId: nombreCliente,
            cuenta: cuentaParaCache,
            operacion,
            message: `Cuenta ${operacion} correctamente`
        };
        
    } catch (error) {
        console.error('‚ùå Error creando/actualizando cuenta activa:', error);
        
        if (error.code) {
            throw error;
        }
        
        throw {
            code: 'accounts/create-update-error',
            message: 'Error al procesar la cuenta activa',
            originalError: error
        };
    }
}

/**
 * Procesa el pago de una cuenta activa (la mueve a cuentasCerradas)
 * @param {string} nombreCliente - Nombre del cliente
 * @param {Object} datosPago - Datos del pago
 * @returns {Promise<Object>} Resultado de la operaci√≥n
 */
export async function pagarCuentaActiva(nombreCliente, datosPago = {}) {
    try {
        validarSesionActiva();
        
        // Obtener cuenta activa
        const cuenta = await buscarCuentaPorCliente(nombreCliente);
        
        if (!cuenta) {
            throw {
                code: 'accounts/not-found',
                message: 'Cuenta activa no encontrada'
            };
        }
        
        const montoPago = datosPago.monto || cuenta.total;
        const metodoPago = datosPago.metodoPago || METODOS_PAGO.EFECTIVO;
        
        console.log(`üîÑ Procesando pago de cuenta: ${nombreCliente} - $${montoPago}`);
        
        // 1. Mover datos a cuentasCerradas (usando la l√≥gica de VentasApp.js)
        await moverCuentaACuentasCerradas(cuenta, metodoPago, montoPago);
        
        // 2. Eliminar de cuentasActivas
        const cuentaActivaRef = doc(db, "cuentasActivas", nombreCliente);
        await deleteDoc(cuentaActivaRef);
        
        // 3. Limpiar cach√©
        cuentasCache.delete(nombreCliente);
        
        console.log(`‚úÖ Pago procesado: ${nombreCliente} - $${montoPago}`);
        
        return {
            success: true,
            clienteId: nombreCliente,
            montoPago,
            metodoPago,
            nuevoEstado: ESTADOS_CUENTA.PAGADA,
            message: `Pago de $${montoPago} procesado correctamente`
        };
        
    } catch (error) {
        console.error('‚ùå Error procesando pago:', error);
        
        if (error.code) {
            throw error;
        }
        
        throw {
            code: 'accounts/payment-error',
            message: 'Error al procesar el pago',
            originalError: error
        };
    }
}

/**
 * Mueve una cuenta activa a cuentasCerradas
 * @param {Object} cuenta - Datos de la cuenta
 * @param {string} metodoPago - M√©todo de pago utilizado
 * @param {number} montoPago - Monto pagado
 * @returns {Promise<void>}
 */
async function moverCuentaACuentasCerradas(cuenta, metodoPago, montoPago) {
    try {
        const turnoId = getCurrentTurnoId() || cuenta.turnoId;
        
        if (!turnoId) {
            throw new Error('No se puede determinar el turno para guardar la venta');
        }
        
        // üîß CORRECCI√ìN: Guardar en colecci√≥n 'cuentasCerradas' con estructura correcta
        const cuentaCerradaRef = doc(db, "cuentasCerradas", turnoId);
        const cuentaCerradaSnap = await getDoc(cuentaCerradaRef);
        
        // Convertir productos de objeto a array
        const productosArray = [];
        if (cuenta.productos && typeof cuenta.productos === 'object') {
            Object.entries(cuenta.productos).forEach(([nombreProducto, detalles]) => {
                productosArray.push({
                    nombre: nombreProducto,
                    cantidad: detalles.cantidad || 1,
                    precioVenta: detalles.precioVenta || detalles.precio || 0,
                    total: detalles.total || (detalles.cantidad * detalles.precioVenta) || 0
                });
            });
        }
        
        const ventaCompleta = {
            nombre: cuenta.clienteNombre,
            productos: productosArray,
            tipoVenta: metodoPago,
            total: montoPago
        };
        
        let datosCuentaCerrada;
        
        if (cuentaCerradaSnap.exists()) {
            // Documento existe, agregar cliente al array
            datosCuentaCerrada = cuentaCerradaSnap.data();
            
            if (!Array.isArray(datosCuentaCerrada.cliente)) {
                datosCuentaCerrada.cliente = [];
            }
            
            datosCuentaCerrada.cliente.push(ventaCompleta);
            
        } else {
            // Crear nuevo documento
            datosCuentaCerrada = {
                cliente: [ventaCompleta],
                fechaCreacion: serverTimestamp(),
                turnoId: turnoId
            };
        }
        
        // Actualizar fecha de √∫ltima modificaci√≥n
        datosCuentaCerrada.fechaUltimaModificacion = serverTimestamp();
        
        // Guardar en Firebase
        await setDoc(cuentaCerradaRef, datosCuentaCerrada);
        
        console.log(`‚úÖ Cuenta movida a cuentasCerradas: ${cuenta.clienteNombre}`);
        
    } catch (error) {
        console.error('‚ùå Error moviendo cuenta a cerradas:', error);
        throw error;
    }
}

/**
 * Cancela una cuenta activa
 * @param {string} nombreCliente - Nombre del cliente
 * @param {string} motivo - Motivo de la cancelaci√≥n
 * @returns {Promise<Object>} Resultado de la operaci√≥n
 */
export async function cancelarCuentaActiva(nombreCliente, motivo = '') {
    try {
        validarSesionActiva();
        
        const cuenta = await buscarCuentaPorCliente(nombreCliente);
        
        if (!cuenta) {
            throw {
                code: 'accounts/not-found',
                message: 'Cuenta activa no encontrada'
            };
        }
        
        // Eliminar de cuentasActivas
        const cuentaActivaRef = doc(db, "cuentasActivas", nombreCliente);
        await deleteDoc(cuentaActivaRef);
        
        // Limpiar cach√©
        cuentasCache.delete(nombreCliente);
        
        console.log(`üö´ Cuenta cancelada: ${nombreCliente} - Motivo: ${motivo}`);
        
        return {
            success: true,
            clienteId: nombreCliente,
            montoLiberado: cuenta.total,
            motivo,
            message: 'Cuenta cancelada correctamente'
        };
        
    } catch (error) {
        console.error('‚ùå Error cancelando cuenta:', error);
        
        if (error.code) {
            throw error;
        }
        
        throw {
            code: 'accounts/cancel-error',
            message: 'Error al cancelar la cuenta',
            originalError: error
        };
    }
}

// === FUNCIONES DE B√öSQUEDA Y FILTRADO ===

/**
 * Busca cuentas por texto (nombre del cliente)
 * @param {string} filtro - Texto a buscar
 * @returns {Promise<Array>} Cuentas encontradas
 */
export async function buscarCuentas(filtro) {
    try {
        const cuentas = await obtenerCuentasPendientes();
        
        if (!filtro?.trim()) {
            return cuentas;
        }
        
        const filtroNormalizado = normalizarTexto(filtro);
        
        const cuentasFiltradas = cuentas.filter(cuenta => {
            const nombre = normalizarTexto(cuenta.clienteNombre || cuenta.cliente);
            const telefono = normalizarTelefono(cuenta.clienteTelefono || '');
            
            return nombre.includes(filtroNormalizado) ||
                   telefono.includes(filtro.replace(/\D/g, ''));
        });
        
        console.log(`üîç B√∫squeda de cuentas "${filtro}": ${cuentasFiltradas.length} encontradas`);
        return cuentasFiltradas;
        
    } catch (error) {
        console.error('‚ùå Error buscando cuentas:', error);
        throw {
            code: 'accounts/search-error',
            message: 'Error al buscar cuentas',
            originalError: error
        };
    }
}

/**
 * Obtiene las cuentas de un cliente espec√≠fico
 * @param {string} clienteId - ID del cliente (nombre)
 * @param {string} estado - Estado de las cuentas a filtrar
 * @returns {Promise<Array>} Array de cuentas del cliente
 */
export async function obtenerCuentasCliente(clienteId, estado = null) {
    try {
        console.log(`üîÑ Obteniendo cuentas del cliente: ${clienteId}`);
        
        // En esta estructura, cada cliente tiene m√°ximo una cuenta activa
        const cuenta = await buscarCuentaPorCliente(clienteId);
        
        if (!cuenta) {
            console.log(`‚ÑπÔ∏è No se encontr√≥ cuenta para el cliente: ${clienteId}`);
            return [];
        }
        
        // Filtrar por estado si se especifica
        if (estado && cuenta.estado !== estado) {
            return [];
        }
        
        console.log(`‚úÖ Cuenta del cliente obtenida: ${clienteId}`);
        return [cuenta]; // Retornar array con una cuenta
        
    } catch (error) {
        console.error('‚ùå Error obteniendo cuentas del cliente:', error);
        throw {
            code: 'accounts/fetch-error',
            message: 'Error al obtener las cuentas del cliente',
            originalError: error
        };
    }
}

// === FUNCIONES DE UTILIDAD ===

/**
 * Invalida el cach√© de cuentas
 */
export function invalidarCacheCuentas() {
    cuentasCache.clear();
    clientesCache.clear();
    lastFetchTime = 0;
    console.log('üóëÔ∏è Cach√© de cuentas invalidado');
}

/**
 * Obtiene estad√≠sticas de cuentas activas
 * @returns {Promise<Object>} Estad√≠sticas
 */
export async function obtenerEstadisticasCuentas() {
    try {
        const cuentasActivas = await obtenerCuentasPendientes();
        
        const totalCuentasActivas = cuentasActivas.length;
        const montoTotalPendiente = cuentasActivas.reduce((sum, cuenta) => sum + cuenta.total, 0);
        const promedioDeudaPorCliente = totalCuentasActivas > 0 ? montoTotalPendiente / totalCuentasActivas : 0;
        
        // Cuentas por turno
        const cuentasPorTurno = {};
        cuentasActivas.forEach(cuenta => {
            const turno = cuenta.turnoId || 'Sin turno';
            if (!cuentasPorTurno[turno]) {
                cuentasPorTurno[turno] = {
                    cantidad: 0,
                    monto: 0
                };
            }
            cuentasPorTurno[turno].cantidad++;
            cuentasPorTurno[turno].monto += cuenta.total;
        });
        
        return {
            totalCuentasActivas,
            montoTotalPendiente,
            promedioDeudaPorCliente,
            cuentasPorTurno,
            fechaActualizacion: new Date().toISOString()
        };
        
    } catch (error) {
        console.error('‚ùå Error obteniendo estad√≠sticas:', error);
        throw {
            code: 'accounts/stats-error',
            message: 'Error al obtener estad√≠sticas de cuentas',
            originalError: error
        };
    }
}

// === GESTI√ìN DE CLIENTES (FUNCIONES COMPATIBILIDAD) ===

/**
 * Obtiene informaci√≥n b√°sica de clientes desde las cuentas activas
 * @returns {Promise<Array>} Array de clientes con cuentas activas
 */
export async function obtenerClientes() {
    try {
        const cuentasActivas = await obtenerCuentasPendientes();
        
        const clientes = cuentasActivas.map(cuenta => ({
            id: cuenta.clienteId,
            nombre: cuenta.clienteNombre,
            telefono: cuenta.clienteTelefono || '',
            saldoPendiente: cuenta.total,
            fechaUltimaCuenta: cuenta.fechaCreacion,
            tieneCuentaActiva: true
        }));
        
        return clientes;
        
    } catch (error) {
        console.error('‚ùå Error obteniendo clientes:', error);
        throw {
            code: 'clients/fetch-error',
            message: 'Error al obtener los clientes',
            originalError: error
        };
    }
}

/**
 * Busca un cliente por ID (nombre)
 * @param {string} clienteId - ID del cliente
 * @returns {Promise<Object|null>} Cliente encontrado o null
 */
export async function buscarClientePorId(clienteId) {
    try {
        const cuenta = await buscarCuentaPorCliente(clienteId);
        
        if (!cuenta) {
            return null;
        }
        
        return {
            id: cuenta.clienteId,
            nombre: cuenta.clienteNombre,
            telefono: cuenta.clienteTelefono || '',
            saldoPendiente: cuenta.total,
            fechaUltimaCuenta: cuenta.fechaCreacion,
            tieneCuentaActiva: true
        };
        
    } catch (error) {
        console.error('‚ùå Error buscando cliente:', error);
        throw {
            code: 'clients/search-error',
            message: 'Error al buscar el cliente',
            originalError: error
        };
    }
}

// === FUNCIONES DE COMPATIBILIDAD PARA C√ìDIGO EXISTENTE ===

/**
 * Funci√≥n de compatibilidad
 * @deprecated Usar obtenerCuentasPendientes en su lugar
 */
export async function cargarCuentas() {
    console.warn('‚ö†Ô∏è cargarCuentas() est√° deprecada, usa obtenerCuentasPendientes()');
    return await obtenerCuentasPendientes();
}

/**
 * Funci√≥n de compatibilidad
 * @deprecated Usar buscarCuentaPorCliente en su lugar
 */
export async function cargarDetalleCuenta(cuentaId) {
    console.warn('‚ö†Ô∏è cargarDetalleCuenta() est√° deprecada, usa buscarCuentaPorCliente()');
    return await buscarCuentaPorCliente(cuentaId);
}

/**
 * Funci√≥n de compatibilidad para crear cuentas
 * @deprecated Usar crearOActualizarCuentaActiva en su lugar
 */
export async function crearCuenta(datosCuenta) {
    console.warn('‚ö†Ô∏è crearCuenta() est√° deprecada, usa crearOActualizarCuentaActiva()');
    return await crearOActualizarCuentaActiva(datosCuenta);
}

/**
 * Funci√≥n de compatibilidad para pagos
 * @deprecated Usar pagarCuentaActiva en su lugar
 */
export async function pagarCuenta(cuentaId, datosPago) {
    console.warn('‚ö†Ô∏è pagarCuenta() est√° deprecada, usa pagarCuentaActiva()');
    return await pagarCuentaActiva(cuentaId, datosPago);
}

// === EXPORTACIONES DE CONSTANTES ===
export { ESTADOS_CUENTA, TIPOS_MOVIMIENTO, METODOS_PAGO };

// === LOGGING DE DEBUG (SOLO EN DESARROLLO) ===
if (typeof window !== 'undefined' && (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1')) {
    console.group('üè™ Accounts Module Debug Info');
    console.log('DB instance:', db);
    console.log('Estados de cuenta:', ESTADOS_CUENTA);
    console.log('Tipos de movimiento:', TIPOS_MOVIMIENTO);
    console.log('M√©todos de pago:', METODOS_PAGO);
    console.log('Cache duration:', CACHE_DURATION, 'ms');
    console.groupEnd();
}















- Archivo 10: JavaScript buscadorvoz

// === ESTADO INTERNO DEL M√ìDULO ===
let recognition = null;
let isListening = false;
let isSupported = false;
let currentConfig = {
    language: 'es-ES',
    continuous: false,
    interimResults: true,
    maxAlternatives: 1,
    timeout: 10000 // 10 segundos
};

// === CONSTANTES ===
const EVENTOS_VOZ = {
    INICIO: 'voz_inicio',
    RESULTADO: 'voz_resultado',
    ERROR: 'voz_error',
    FIN: 'voz_fin',
    DISPONIBLE: 'voz_disponible',
    NO_DISPONIBLE: 'voz_no_disponible'
};

const ERRORES_VOZ = {
    NO_SPEECH: 'no-speech',
    ABORTED: 'aborted',
    AUDIO_CAPTURE: 'audio-capture',
    NETWORK: 'network',
    NOT_ALLOWED: 'not-allowed',
    SERVICE_NOT_ALLOWED: 'service-not-allowed',
    BAD_GRAMMAR: 'bad-grammar',
    LANGUAGE_NOT_SUPPORTED: 'language-not-supported',
    NO_SUPPORT: 'no-support',
    TIMEOUT: 'timeout'
};

const MENSAJES_ERROR = {
    [ERRORES_VOZ.NO_SPEECH]: 'No se detect√≥ ning√∫n sonido. Int√©ntalo de nuevo.',
    [ERRORES_VOZ.ABORTED]: 'Reconocimiento de voz cancelado.',
    [ERRORES_VOZ.AUDIO_CAPTURE]: 'No se pudo acceder al micr√≥fono.',
    [ERRORES_VOZ.NETWORK]: 'Error de conexi√≥n de red.',
    [ERRORES_VOZ.NOT_ALLOWED]: 'Micr√≥fono bloqueado. Permite el acceso para usar esta funci√≥n.',
    [ERRORES_VOZ.SERVICE_NOT_ALLOWED]: 'Servicio de reconocimiento de voz no permitido.',
    [ERRORES_VOZ.BAD_GRAMMAR]: 'Error en la configuraci√≥n de gram√°tica.',
    [ERRORES_VOZ.LANGUAGE_NOT_SUPPORTED]: 'Idioma no soportado.',
    [ERRORES_VOZ.NO_SUPPORT]: 'Tu navegador no soporta reconocimiento de voz.',
    [ERRORES_VOZ.TIMEOUT]: 'Tiempo de espera agotado. Int√©ntalo de nuevo.'
};

// === SISTEMA DE EVENTOS ===
const eventListeners = new Map();

/**
 * Suscribe a eventos de reconocimiento de voz
 * @param {string} evento - Nombre del evento
 * @param {Function} callback - Funci√≥n a ejecutar
 * @returns {Function} Funci√≥n para desuscribirse
 */
export function suscribirEventoVoz(evento, callback) {
    if (!eventListeners.has(evento)) {
        eventListeners.set(evento, new Set());
    }
    
    eventListeners.get(evento).add(callback);
    
    // Retornar funci√≥n para desuscribirse
    return () => {
        const listeners = eventListeners.get(evento);
        if (listeners) {
            listeners.delete(callback);
        }
    };
}

function emitirEvento(evento, data) {
    const listeners = eventListeners.get(evento);
    if (listeners) {
        listeners.forEach(callback => {
            try {
                callback(data);
            } catch (error) {
                console.error(`‚ùå Error en listener de evento ${evento}:`, error);
            }
        });
    }
}

// === FUNCIONES DE DETECCI√ìN Y CONFIGURACI√ìN ===

/**
 * Verifica si el navegador soporta reconocimiento de voz
 * @returns {boolean} True si est√° soportado
 */
export function esReconocimientoVozSoportado() {
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    return !!SpeechRecognition && typeof SpeechRecognition === 'function';
}

/**
 * Verifica si hay permisos de micr√≥fono
 * @returns {Promise<boolean>} True si hay permisos
 */
export async function verificarPermisosMicrofono() {
    try {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            return false;
        }
        
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        
        // Cerrar el stream inmediatamente
        stream.getTracks().forEach(track => track.stop());
        
        return true;
        
    } catch (error) {
        console.warn('‚ö†Ô∏è Sin permisos de micr√≥fono:', error.name);
        return false;
    }
}

/**
 * Inicializa el reconocimiento de voz
 * @param {Object} config - Configuraci√≥n opcional
 * @returns {Promise<Object>} Resultado de la inicializaci√≥n
 */
export async function inicializarReconocimientoVoz(config = {}) {
    try {
        // Verificar soporte del navegador
        if (!esReconocimientoVozSoportado()) {
            isSupported = false;
            const resultado = {
                success: false,
                supported: false,
                error: ERRORES_VOZ.NO_SUPPORT,
                message: MENSAJES_ERROR[ERRORES_VOZ.NO_SUPPORT]
            };
            
            emitirEvento(EVENTOS_VOZ.NO_DISPONIBLE, resultado);
            return resultado;
        }
        
        // Verificar permisos de micr√≥fono
        const tienePermisos = await verificarPermisosMicrofono();
        if (!tienePermisos) {
            console.warn('‚ö†Ô∏è Sin permisos de micr√≥fono, el usuario deber√° otorgarlos al usar la funci√≥n');
        }
        
        // Aplicar configuraci√≥n personalizada
        currentConfig = { ...currentConfig, ...config };
        
        // Crear instancia de reconocimiento
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        recognition = new SpeechRecognition();
        
        // Configurar propiedades
        recognition.continuous = currentConfig.continuous;
        recognition.interimResults = currentConfig.interimResults;
        recognition.lang = currentConfig.language;
        recognition.maxAlternatives = currentConfig.maxAlternatives;
        
        // Configurar eventos del reconocimiento
        configurarEventosReconocimiento();
        
        isSupported = true;
        
        const resultado = {
            success: true,
            supported: true,
            config: { ...currentConfig },
            hasPermissions: tienePermisos,
            message: 'Reconocimiento de voz inicializado correctamente'
        };
        
        console.log('üé§ Reconocimiento de voz inicializado');
        emitirEvento(EVENTOS_VOZ.DISPONIBLE, resultado);
        
        return resultado;
        
    } catch (error) {
        console.error('‚ùå Error inicializando reconocimiento de voz:', error);
        
        isSupported = false;
        const resultado = {
            success: false,
            supported: false,
            error: 'initialization-error',
            message: 'Error al inicializar el reconocimiento de voz',
            originalError: error
        };
        
        emitirEvento(EVENTOS_VOZ.ERROR, resultado);
        return resultado;
    }
}

function configurarEventosReconocimiento() {
    if (!recognition) return;
    
    let timeoutId = null;
    
    recognition.onstart = () => {
        isListening = true;
        console.log('üé§ Reconocimiento de voz iniciado');
        
        // Configurar timeout
        if (currentConfig.timeout > 0) {
            timeoutId = setTimeout(() => {
                if (isListening) {
                    detenerReconocimiento();
                    emitirEvento(EVENTOS_VOZ.ERROR, {
                        error: ERRORES_VOZ.TIMEOUT,
                        message: MENSAJES_ERROR[ERRORES_VOZ.TIMEOUT]
                    });
                }
            }, currentConfig.timeout);
        }
        
        emitirEvento(EVENTOS_VOZ.INICIO, { 
            timestamp: Date.now(),
            config: { ...currentConfig }
        });
    };
    
    recognition.onresult = (event) => {
        if (timeoutId) {
            clearTimeout(timeoutId);
            timeoutId = null;
        }
        
        let transcript = '';
        let confidence = 0;
        let isFinal = false;
        
        // Procesar todos los resultados
        for (let i = event.resultIndex; i < event.results.length; i++) {
            const result = event.results[i];
            transcript += result[0].transcript;
            confidence = Math.max(confidence, result[0].confidence || 0);
            
            if (result.isFinal) {
                isFinal = true;
            }
        }
        
        const resultado = {
            transcript: transcript.trim(),
            confidence,
            isFinal,
            timestamp: Date.now()
        };
        
        console.log(`üé§ ${isFinal ? 'Resultado final' : 'Resultado parcial'}: "${transcript}" (${Math.round(confidence * 100)}%)`);
        
        emitirEvento(EVENTOS_VOZ.RESULTADO, resultado);
    };
    
    recognition.onerror = (event) => {
        if (timeoutId) {
            clearTimeout(timeoutId);
            timeoutId = null;
        }
        
        isListening = false;
        
        const errorCode = mapearErrorVoz(event.error);
        const resultado = {
            error: errorCode,
            message: MENSAJES_ERROR[errorCode] || 'Error desconocido en el reconocimiento de voz',
            originalError: event.error,
            timestamp: Date.now()
        };
        
        console.error('‚ùå Error en reconocimiento de voz:', resultado);
        emitirEvento(EVENTOS_VOZ.ERROR, resultado);
    };
    
    recognition.onend = () => {
        if (timeoutId) {
            clearTimeout(timeoutId);
            timeoutId = null;
        }
        
        isListening = false;
        console.log('üé§ Reconocimiento de voz finalizado');
        
        emitirEvento(EVENTOS_VOZ.FIN, { 
            timestamp: Date.now() 
        });
    };
}

function mapearErrorVoz(error) {
    const errorMap = {
        'no-speech': ERRORES_VOZ.NO_SPEECH,
        'aborted': ERRORES_VOZ.ABORTED,
        'audio-capture': ERRORES_VOZ.AUDIO_CAPTURE,
        'network': ERRORES_VOZ.NETWORK,
        'not-allowed': ERRORES_VOZ.NOT_ALLOWED,
        'service-not-allowed': ERRORES_VOZ.SERVICE_NOT_ALLOWED,
        'bad-grammar': ERRORES_VOZ.BAD_GRAMMAR,
        'language-not-supported': ERRORES_VOZ.LANGUAGE_NOT_SUPPORTED
    };
    
    return errorMap[error] || error;
}

// === FUNCIONES PRINCIPALES ===

/**
 * Inicia el reconocimiento de voz
 * @returns {Promise<Object>} Resultado de la operaci√≥n
 */
export async function iniciarReconocimiento() {
    try {
        if (!isSupported) {
            throw {
                code: 'voice/not-supported',
                message: 'Reconocimiento de voz no soportado'
            };
        }
        
        if (!recognition) {
            throw {
                code: 'voice/not-initialized',
                message: 'Reconocimiento de voz no inicializado'
            };
        }
        
        if (isListening) {
            throw {
                code: 'voice/already-listening',
                message: 'El reconocimiento de voz ya est√° activo'
            };
        }
        
        recognition.start();
        
        return {
            success: true,
            message: 'Reconocimiento de voz iniciado'
        };
        
    } catch (error) {
        console.error('‚ùå Error iniciando reconocimiento:', error);
        
        if (error.code) {
            throw error;
        }
        
        throw {
            code: 'voice/start-error',
            message: 'Error al iniciar el reconocimiento de voz',
            originalError: error
        };
    }
}

/**
 * Detiene el reconocimiento de voz
 * @returns {Object} Resultado de la operaci√≥n
 */
export function detenerReconocimiento() {
    try {
        if (!isSupported || !recognition) {
            return {
                success: false,
                message: 'Reconocimiento de voz no disponible'
            };
        }
        
        if (!isListening) {
            return {
                success: false,
                message: 'El reconocimiento de voz no est√° activo'
            };
        }
        
        recognition.stop();
        
        return {
            success: true,
            message: 'Reconocimiento de voz detenido'
        };
        
    } catch (error) {
        console.error('‚ùå Error deteniendo reconocimiento:', error);
        return {
            success: false,
            message: 'Error al detener el reconocimiento de voz',
            error
        };
    }
}

/**
 * Cancela el reconocimiento de voz
 * @returns {Object} Resultado de la operaci√≥n
 */
export function cancelarReconocimiento() {
    try {
        if (!isSupported || !recognition) {
            return {
                success: false,
                message: 'Reconocimiento de voz no disponible'
            };
        }
        
        if (!isListening) {
            return {
                success: false,
                message: 'El reconocimiento de voz no est√° activo'
            };
        }
        
        recognition.abort();
        
        return {
            success: true,
            message: 'Reconocimiento de voz cancelado'
        };
        
    } catch (error) {
        console.error('‚ùå Error cancelando reconocimiento:', error);
        return {
            success: false,
            message: 'Error al cancelar el reconocimiento de voz',
            error
        };
    }
}

// === FUNCIONES DE CONSULTA ===

/**
 * Obtiene el estado actual del reconocimiento de voz
 * @returns {Object} Estado actual
 */
export function obtenerEstadoVoz() {
    return {
        isSupported,
        isListening,
        isInitialized: !!recognition,
        config: { ...currentConfig }
    };
}

/**
 * Verifica si est√° escuchando actualmente
 * @returns {boolean} True si est√° escuchando
 */
export function estaEscuchando() {
    return isListening;
}

/**
 * Verifica si el reconocimiento de voz est√° disponible
 * @returns {boolean} True si est√° disponible
 */
export function estaDisponible() {
    return isSupported && !!recognition;
}

// === FUNCIONES DE CONFIGURACI√ìN ===

/**
 * Actualiza la configuraci√≥n del reconocimiento de voz
 * @param {Object} nuevaConfig - Nueva configuraci√≥n
 * @returns {Object} Configuraci√≥n actualizada
 */
export function actualizarConfiguracion(nuevaConfig) {
    const configAnterior = { ...currentConfig };
    currentConfig = { ...currentConfig, ...nuevaConfig };
    
    // Aplicar configuraci√≥n si hay una instancia activa
    if (recognition) {
        recognition.continuous = currentConfig.continuous;
        recognition.interimResults = currentConfig.interimResults;
        recognition.lang = currentConfig.language;
        recognition.maxAlternatives = currentConfig.maxAlternatives;
    }
    
    console.log('üîß Configuraci√≥n de voz actualizada');
    
    return {
        configAnterior,
        configNueva: { ...currentConfig },
        cambios: Object.keys(nuevaConfig)
    };
}

/**
 * Obtiene la configuraci√≥n actual
 * @returns {Object} Configuraci√≥n actual
 */
export function obtenerConfiguracion() {
    return { ...currentConfig };
}

// === FUNCIONES DE UTILIDAD PARA B√öSQUEDA ===

/**
 * Procesa texto de voz para b√∫squeda (MEJORADO para caracteres especiales)
 * @param {string} transcript - Texto transcrito
 * @returns {Object} Texto procesado para b√∫squeda
 */
export function procesarTextoParaBusqueda(transcript) {
    if (!transcript || typeof transcript !== 'string') {
        return {
            original: '',
            procesado: '',
            palabras: [],
            esValido: false
        };
    }
      
    // üîß MEJORADO: Normalizar texto con mapeo de caracteres especiales para voz
    let textoNormalizado = transcript
        .toLowerCase()
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g, ""); // Remover tildes
    
    // üîß NUEVO: Mapeo de palabras com√∫nmente mal interpretadas por reconocimiento de voz
    const mapeoVoz = {
        // S√≠mbolos convertidos a palabras
        '&': ' y ',
        '+': ' mas ',
        '@': ' arroba ',
        '%': ' por ciento ',
        '#': ' numero ',
        '$': ' peso ',
        '¬∞': ' grado ',
        
        // Correcciones de pronunciaci√≥n comunes
        'cola': 'pola', // Tambi√©n funciona al rev√©s
        'pola': 'cola', // Para que "cola pola" encuentre "Pola & Pola"
        'and': 'y',
        'i': 'y', // Cuando se confunde "y" con "i"
        'e': 'y'  // Cuando se confunde "y" con "e"
    };
    
    // Aplicar mapeos de s√≠mbolos
    Object.keys(mapeoVoz).forEach(simbolo => {
        if (simbolo.length === 1 && /[^\w\s]/.test(simbolo)) { // Solo s√≠mbolos
            const variante = mapeoVoz[simbolo];
            textoNormalizado = textoNormalizado.replace(new RegExp(`\\${simbolo}`, 'g'), variante);
        }
    });
    
    // Limpiar caracteres especiales restantes
    textoNormalizado = textoNormalizado
        .replace(/[^\w\s]/g, ' ') // Remover caracteres especiales restantes
        .replace(/\s+/g, ' ') // Normalizar espacios m√∫ltiples
        .trim();
    
    // üîß NUEVO: Generar variaciones para b√∫squeda
    const variaciones = [];
    
    // Variaci√≥n original
    variaciones.push(textoNormalizado);
    
    // Aplicar correcciones de pronunciaci√≥n
    let textoConVariaciones = textoNormalizado;
    Object.keys(mapeoVoz).forEach(palabra => {
        if (palabra.length > 1) { // Solo palabras, no s√≠mbolos
            const variante = mapeoVoz[palabra];
            if (textoConVariaciones.includes(palabra)) {
                const nuevaVariacion = textoConVariaciones.replace(new RegExp(palabra, 'g'), variante);
                if (nuevaVariacion !== textoConVariaciones) {
                    variaciones.push(nuevaVariacion);
                }
            }
        }
    });

    // Agregar variaciones generadas
    variaciones.push(textoConVariaciones);

    const palabras = textoNormalizado.split(' ').filter(p => p.length > 0);
    
    return {
        original: transcript,
        procesado: textoNormalizado,
        variaciones: [...new Set(variaciones)], // üîß NUEVO: Lista de variaciones
        palabras,
        esValido: palabras.length > 0 && textoNormalizado.length >= 2
    };
}

// === FUNCI√ìN INTEGRADA DE B√öSQUEDA POR VOZ ===

/**
 * Inicia una b√∫squeda por voz con callback personalizado
 * @param {Function} onResultado - Callback para manejar resultados
 * @param {Object} opciones - Opciones de b√∫squeda
 * @returns {Promise<Object>} Resultado de la operaci√≥n
 */
export async function iniciarBusquedaPorVoz(onResultado, opciones = {}) {
    try {
        if (typeof onResultado !== 'function') {
            throw {
                code: 'voice/invalid-callback',
                message: 'Se requiere una funci√≥n callback para manejar los resultados'
            };
        }
        
        // Configurar opciones espec√≠ficas para b√∫squeda
        const configBusqueda = {
            continuous: false,
            interimResults: true,
            timeout: opciones.timeout || 8000,
            ...opciones.config
        };
        
        // Actualizar configuraci√≥n temporalmente
        const configOriginal = { ...currentConfig };
        actualizarConfiguracion(configBusqueda);
        
         // Suscribirse a eventos de resultados
        const unsuscribirResultado = suscribirEventoVoz(EVENTOS_VOZ.RESULTADO, async (data) => {
            const comandos = extraerComandosVoz(data.transcript);
            
            // üîß NUEVO: Si es resultado final, intentar b√∫squeda en inventario
            let resultadoInventario = null;
            if (data.isFinal && comandos.textoBusqueda) {
                try {
                    // Importar funci√≥n de b√∫squeda din√°micamente
                    const { buscarPorVoz } = await import('./Inventario.js');
                    const productos = await buscarPorVoz(comandos.textoBusqueda);
                    
                    resultadoInventario = {
                        productos,
                        totalEncontrados: productos.length,
                        textoBusquedaUsado: comandos.textoBusqueda
                    };
                } catch (error) {
                    console.warn('‚ö†Ô∏è Error en b√∫squeda de inventario:', error);
                }
            }
            
            onResultado({
                ...data,
                ...comandos,
                esComando: comandos.hayComandos,
                inventario: resultadoInventario // üîß NUEVO: Agregar resultados de inventario
            });
        });
        
        const unsuscribirError = suscribirEventoVoz(EVENTOS_VOZ.ERROR, (error) => {
            // Restaurar configuraci√≥n original
            actualizarConfiguracion(configOriginal);
            unsuscribirResultado();
            unsuscribirError();
        });
        
        const unsuscribirFin = suscribirEventoVoz(EVENTOS_VOZ.FIN, () => {
            // Restaurar configuraci√≥n original
            actualizarConfiguracion(configOriginal);
            unsuscribirResultado();
            unsuscribirError();
            unsuscribirFin();
        });
        
        // Iniciar reconocimiento
        const resultado = await iniciarReconocimiento();
        
        return {
            ...resultado,
            config: configBusqueda,
            callbacks: {
                unsuscribirResultado,
                unsuscribirError,
                unsuscribirFin
            }
        };
        
    } catch (error) {
        console.error('‚ùå Error iniciando b√∫squeda por voz:', error);
        
        if (error.code) {
            throw error;
        }
        
        throw {
            code: 'voice/search-error',
            message: 'Error al iniciar b√∫squeda por voz',
            originalError: error
        };
    }
}

/**
 * Extrae comandos de voz comunes
 * @param {string} transcript - Texto transcrito
 * @returns {Object} Comandos detectados
 */
export function extraerComandosVoz(transcript) {
    const texto = procesarTextoParaBusqueda(transcript);
    
    if (!texto.esValido) {
        return {
            hayComandos: false,
            comandos: [],
            textoBusqueda: ''
        };
    }
    
    const comandos = [];
    let textoBusqueda = texto.procesado;
    
    // Detectar comandos comunes
    const patronesComandos = {
        'buscar': /^(buscar|busca|encuentra|mostrar|ver)\s+(.+)/i,
        'agregar': /^(agregar|agrega|a√±adir|anadir)\s+(.+)/i,
        'eliminar': /^(eliminar|elimina|quitar|borrar)\s+(.+)/i,
        'cancelar': /^(cancelar|cancela|parar|para|detener|stop)/i,
        'limpiar': /^(limpiar|limpia|borrar todo|vaciar)/i,
        'ayuda': /^(ayuda|help|que puedo decir)/i
    };
    
    for (const [comando, patron] of Object.entries(patronesComandos)) {
        const match = texto.original.match(patron);
        if (match) {
            comandos.push({
                comando,
                parametro: match[2] ? match[2].trim() : null,
                textoCompleto: match[0]
            });
            
            // Para comandos de b√∫squeda, extraer el t√©rmino
            if (comando === 'buscar' && match[2]) {
                textoBusqueda = procesarTextoParaBusqueda(match[2]).procesado;
            }
            
            break; // Solo un comando por transcript
        }
    }
    
    // Si no hay comandos espec√≠ficos, tratar todo como b√∫squeda
    if (comandos.length === 0) {
        textoBusqueda = texto.procesado;
    }
    
    return {
        hayComandos: comandos.length > 0,
        comandos,
        textoBusqueda,
        textoOriginal: transcript,
        textoProcesado: texto.procesado
    };
}

// === FUNCIONES DE COMPATIBILIDAD ===
// Para mantener compatibilidad con c√≥digo existente

export async function iniciarBusquedaVoz() {
    console.warn('‚ö†Ô∏è iniciarBusquedaVoz() est√° deprecada, usa iniciarBusquedaPorVoz()');
    
    return new Promise((resolve, reject) => {
        iniciarBusquedaPorVoz((resultado) => {
            if (resultado.isFinal) {
                resolve({
                    transcript: resultado.textoBusqueda || resultado.transcript,
                    confidence: resultado.confidence,
                    comandos: resultado.comandos
                });
            }
        }).catch(reject);
    });
}

// === INICIALIZACI√ìN AUTOM√ÅTICA ===
// Inicializar autom√°ticamente cuando se carga el m√≥dulo
if (typeof document !== 'undefined') {
    // Solo en el navegador
    document.addEventListener('DOMContentLoaded', async () => {
        try {
            const resultado = await inicializarReconocimientoVoz();
            if (resultado.success) {
                console.log('üé§ Buscador de voz listo');
            }
        } catch (error) {
            console.warn('‚ö†Ô∏è Buscador de voz no disponible:', error.message);
        }
    });
}

// === EXPORTACIONES DE CONSTANTES ===
export { EVENTOS_VOZ, ERRORES_VOZ, MENSAJES_ERROR };

// === LOGGING DE DEBUG (SOLO EN DESARROLLO) ===
if (typeof window !== 'undefined' && (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1')) {
    console.group('üé§ Voice Search Module Debug Info');
    console.log('Speech Recognition supported:', esReconocimientoVozSoportado());
    console.log('Default config:', currentConfig);
    console.log('Available events:', EVENTOS_VOZ);
    console.log('Error codes:', ERRORES_VOZ);
    console.groupEnd();
}